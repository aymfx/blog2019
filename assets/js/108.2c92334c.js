(window.webpackJsonp=window.webpackJsonp||[]).push([[108],{621:function(e,n,o){"use strict";o.r(n);var r=o(6),t=Object(r.a)({},(function(){var e=this,n=e.$createElement,o=e._self._c||n;return o("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[o("blockquote",[o("p",[e._v("Promise 实例具有then方法，也就是说，then方法是定义在原型对象Promise.prototype上的。它的作用是为 Promise 实例添加状态改变时的回调函数。前面说过，then方法的第一个参数是Resolved状态的回调函数，第二个参数（可选）是Rejected状态的回调函数")])]),e._v(" "),o("h1",{attrs:{id:"promise-prototype-then"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#promise-prototype-then"}},[e._v("#")]),e._v(" Promise.prototype.then()")]),e._v(" "),o("p",[e._v("Promise 实例具有then方法，也就是说，then方法是定义在原型对象Promise.prototype上的。它的作用是为 Promise 实例添加状态改变时的回调函数。前面说过，then方法的第一个参数是Resolved状态的回调函数，第二个参数（可选）是Rejected状态的回调函数。")]),e._v(" "),o("p",[e._v("then方法返回的是一个新的Promise实例（注意，不是原来那个Promise实例）。因此可以采用链式写法，即then方法后面再调用另一个then方法。")]),e._v(" "),o("div",{staticClass:"language- extra-class"},[o("pre",[o("code",[e._v('getJSON("/posts.json").then(function(json) {\n  return json.post;\n}).then(function(post) {\n  // ...\n});\n')])])]),o("p",[e._v("上面的代码使用then方法，依次指定了两个回调函数。第一个回调函数完成以后，会将返回结果作为参数，传入第二个回调函数。")]),e._v(" "),o("p",[e._v("采用链式的then，可以指定一组按照次序调用的回调函数。这时，前一个回调函数，有可能返回的还是一个Promise对象（即有异步操作），这时后一个回调函数，就会等待该Promise对象的状态发生变化，才会被调用。")]),e._v(" "),o("div",{staticClass:"language- extra-class"},[o("pre",[o("code",[e._v('getJSON("/post/1.json").then(function(post) {\n  return getJSON(post.commentURL);\n}).then(function funcA(comments) {\n  console.log("Resolved: ", comments);\n}, function funcB(err){\n  console.log("Rejected: ", err);\n});\n')])])]),o("p",[e._v("上面代码中，第一个then方法指定的回调函数，返回的是另一个Promise对象。这时，第二个then方法指定的回调函数，就会等待这个新的Promise对象状态发生变化。如果变为Resolved，就调用funcA，如果状态变为Rejected，就调用funcB。")]),e._v(" "),o("p",[e._v("如果采用箭头函数，上面的代码可以写得更简洁。")]),e._v(" "),o("div",{staticClass:"language- extra-class"},[o("pre",[o("code",[e._v('   getJSON("/post/1.json").then(\n      post => getJSON(post.commentURL)\n    ).then(\n      comments => console.log("Resolved: ", comments),\n      err => console.log("Rejected: ", err)\n    );\n# Promise.prototype.catch()\n\nPromise.prototype.catch方法是.then(null, rejection)的别名，用于指定发生错误时的回调函数。\n\ngetJSON(\'/posts.json\').then(function(posts) {\n  // ...\n}).catch(function(error) {\n  // 处理 getJSON 和 前一个回调函数运行时发生的错误\n  console.log(\'发生错误！\', error);\n});\n')])])]),o("p",[e._v("上面代码中，getJSON方法返回一个 Promise 对象，如果该对象状态变为Resolved，则会调用then方法指定的回调函数；如果异步操作抛出错误，状态就会变为Rejected，就会调用catch方法指定的回调函数，处理这个错误。另外，then方法指定的回调函数，如果运行中抛出错误，也会被catch方法捕获。")]),e._v(" "),o("div",{staticClass:"language- extra-class"},[o("pre",[o("code",[e._v("p.then((val) => console.log('fulfilled:', val))\n  .catch((err) => console.log('rejected', err));\n\n// 等同于\np.then((val) => console.log('fulfilled:', val))\n  .then(null, (err) => console.log(\"rejected:\", err));\n")])])]),o("p",[e._v("下面是一个例子。")]),e._v(" "),o("div",{staticClass:"language- extra-class"},[o("pre",[o("code",[e._v("var promise = new Promise(function(resolve, reject) {\n  throw new Error('test');\n});\npromise.catch(function(error) {\n  console.log(error);\n});\n// Error: test\n")])])]),o("p",[e._v("上面代码中，promise抛出一个错误，就被catch方法指定的回调函数捕获。注意，上面的写法与下面两种写法是等价的。")]),e._v(" "),o("div",{staticClass:"language- extra-class"},[o("pre",[o("code",[e._v("// 写法一\nvar promise = new Promise(function(resolve, reject) {\n  try {\n    throw new Error('test');\n  } catch(e) {\n    reject(e);\n  }\n});\npromise.catch(function(error) {\n  console.log(error);\n});\n\n// 写法二\nvar promise = new Promise(function(resolve, reject) {\n  reject(new Error('test'));\n});\npromise.catch(function(error) {\n  console.log(error);\n});\n")])])]),o("p",[e._v("比较上面两种写法，可以发现reject方法的作用，等同于抛出错误。")]),e._v(" "),o("p",[e._v("如果Promise状态已经变成Resolved，再抛出错误是无效的。")]),e._v(" "),o("div",{staticClass:"language- extra-class"},[o("pre",[o("code",[e._v("var promise = new Promise(function(resolve, reject) {\n  resolve('ok');\n  throw new Error('test');\n});\npromise\n  .then(function(value) { console.log(value) })\n  .catch(function(error) { console.log(error) });\n// ok\n")])])]),o("p",[e._v("上面代码中，Promise 在resolve语句后面，再抛出错误，不会被捕获，等于没有抛出。因为 Promise 的状态一旦改变，就永久保持该状态，不会再变了。")]),e._v(" "),o("p",[e._v("Promise 对象的错误具有“冒泡”性质，会一直向后传递，直到被捕获为止。也就是说，错误总是会被下一个catch语句捕获。")]),e._v(" "),o("div",{staticClass:"language- extra-class"},[o("pre",[o("code",[e._v("getJSON('/post/1.json').then(function(post) {\n  return getJSON(post.commentURL);\n}).then(function(comments) {\n  // some code\n}).catch(function(error) {\n  // 处理前面三个Promise产生的错误\n});\n")])])]),o("p",[e._v("上面代码中，一共有三个Promise对象：一个由getJSON产生，两个由then产生。它们之中任何一个抛出的错误，都会被最后一个catch捕获。")]),e._v(" "),o("p",[e._v("一般来说，不要在then方法里面定义Reject状态的回调函数（即then的第二个参数），总是使用catch方法。")]),e._v(" "),o("div",{staticClass:"language- extra-class"},[o("pre",[o("code",[e._v("// bad\npromise\n  .then(function(data) {\n    // success\n  }, function(err) {\n    // error\n  });\n\n// good\npromise\n  .then(function(data) { //cb\n    // success\n  })\n  .catch(function(err) {\n    // error\n  });\n")])])]),o("p",[e._v("上面代码中，第二种写法要好于第一种写法，理由是第二种写法可以捕获前面then方法执行中的错误，也更接近同步的写法（try/catch）。因此，建议总是使用catch方法，而不使用then方法的第二个参数。")]),e._v(" "),o("p",[e._v("跟传统的try/catch代码块不同的是，如果没有使用catch方法指定错误处理的回调函数，Promise对象抛出的错误不会传递到外层代码，即不会有任何反应。")]),e._v(" "),o("div",{staticClass:"language- extra-class"},[o("pre",[o("code",[e._v("var someAsyncThing = function() {\n  return new Promise(function(resolve, reject) {\n    // 下面一行会报错，因为x没有声明\n    resolve(x + 2);\n  });\n};\n\nsomeAsyncThing().then(function() {\n  console.log('everything is great');\n});\n")])])]),o("p",[e._v("上面代码中，someAsyncThing函数产生的 Promise 对象会报错，但是由于没有指定catch方法，这个错误不会被捕获，也不会传递到外层代码。正常情况下，运行后不会有任何输出，但是浏览器此时会打印出错误“ReferenceError: x is not defined”，不过不会终止脚本执行，如果这个脚本放在服务器执行，退出码就是0（即表示执行成功）。")]),e._v(" "),o("p",[e._v("var promise = new Promise(function (resolve, reject) {\nresolve('ok');\nsetTimeout(function () { throw new Error('test') }, 0)\n});\npromise.then(function (value) { console.log(value) });\n// ok\n// Uncaught Error: test\n上面代码中，Promise 指定在下一轮“事件循环”再抛出错误。到了那个时候，Promise 的运行已经结束了，所以这个错误是在 Promise 函数体外抛出的，会冒泡到最外层，成了未捕获的错误。")]),e._v(" "),o("p",[e._v("Node 有一个unhandledRejection事件，专门监听未捕获的reject错误。")]),e._v(" "),o("div",{staticClass:"language- extra-class"},[o("pre",[o("code",[e._v("process.on('unhandledRejection', function (err, p) {\n  console.error(err.stack)\n});\n")])])]),o("p",[e._v("上面代码中，unhandledRejection事件的监听函数有两个参数，第一个是错误对象，第二个是报错的 Promise 实例，它可以用来了解发生错误的环境信息。。")]),e._v(" "),o("p",[e._v("需要注意的是，catch方法返回的还是一个 Promise 对象，因此后面还可以接着调用then方法。")]),e._v(" "),o("div",{staticClass:"language- extra-class"},[o("pre",[o("code",[e._v("var someAsyncThing = function() {\n  return new Promise(function(resolve, reject) {\n    // 下面一行会报错，因为x没有声明\n    resolve(x + 2);\n  });\n};\n\nsomeAsyncThing()\n.catch(function(error) {\n  console.log('oh no', error);\n})\n.then(function() {\n  console.log('carry on');\n});\n// oh no [ReferenceError: x is not defined]\n// carry on\n")])])]),o("p",[e._v("上面代码运行完catch方法指定的回调函数，会接着运行后面那个then方法指定的回调函数。如果没有报错，则会跳过catch方法。")]),e._v(" "),o("div",{staticClass:"language- extra-class"},[o("pre",[o("code",[e._v("Promise.resolve()\n.catch(function(error) {\n  console.log('oh no', error);\n})\n.then(function() {\n  console.log('carry on');\n});\n// carry on\n")])])]),o("p",[e._v("上面的代码因为没有报错，跳过了catch方法，直接执行后面的then方法。此时，要是then方法里面报错，就与前面的catch无关了。")]),e._v(" "),o("div",{staticClass:"language- extra-class"},[o("pre",[o("code",[e._v("catch方法之中，还能再抛出错误。\n\nvar someAsyncThing = function() {\n  return new Promise(function(resolve, reject) {\n    // 下面一行会报错，因为x没有声明\n    resolve(x + 2);\n  });\n};\n\nsomeAsyncThing().then(function() {\n  return someOtherAsyncThing();\n}).catch(function(error) {\n  console.log('oh no', error);\n  // 下面一行会报错，因为y没有声明\n  y + 2;\n}).then(function() {\n  console.log('carry on');\n});\n")])])]),o("p",[e._v("// oh no [ReferenceError: x is not defined]\n上面代码中，catch方法抛出一个错误，因为后面没有别的catch方法了，导致这个错误不会被捕获，也不会传递到外层。如果改写一下，结果就不一样了。")]),e._v(" "),o("div",{staticClass:"language- extra-class"},[o("pre",[o("code",[e._v("someAsyncThing().then(function() {\n  return someOtherAsyncThing();\n}).catch(function(error) {\n  console.log('oh no', error);\n  // 下面一行会报错，因为y没有声明\n  y + 2;\n}).catch(function(error) {\n  console.log('carry on', error);\n});\n// oh no [ReferenceError: x is not defined]\n// carry on [ReferenceError: y is not defined]\n")])])]),o("p",[e._v("上面代码中，第二个catch方法用来捕获，前一个catch方法抛出的错误。")])])}),[],!1,null,null,null);n.default=t.exports}}]);