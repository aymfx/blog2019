(window.webpackJsonp=window.webpackJsonp||[]).push([[46],{560:function(t,a,e){"use strict";e.r(a);var s=e(6),n=Object(s.a)({},(function(){var t=this,a=t.$createElement,e=t._self._c||a;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("p",[e("img",{attrs:{src:"http://upload-images.jianshu.io/upload_images/10843623-c41e6ce3da1d0523.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240",alt:"timg.jpg"}})]),t._v(" "),e("h2",{attrs:{id:"前言"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#前言"}},[t._v("#")]),t._v(" 前言")]),t._v(" "),e("blockquote",[e("p",[t._v("入行这么久了，前端学习的成本感觉越来越高了，不会的东西一茬接一茬，在学校太忽视它，学的半吊子，现在要努力赶上才行，杭州的天气变冷了，我也想回家了，坚持，哎嘿，再上半个月班就要放假了开心。（这是从我自己博客移植过来的）")])]),t._v(" "),e("blockquote",[e("p",[t._v("我的博客地址 ：http://www.aymfx.cn/，欢迎访问")])]),t._v(" "),e("h3",{attrs:{id:"引子"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#引子"}},[t._v("#")]),t._v(" 引子")]),t._v(" "),e("blockquote",[e("p",[t._v("这张理解起来比较费劲，慢慢看，慢慢练,天气比较冷啊，手敲这些好费劲")])]),t._v(" "),e("h3",{attrs:{id:"utf-16码位-基本多文种平面-到辅助平面字符的扩展"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#utf-16码位-基本多文种平面-到辅助平面字符的扩展"}},[t._v("#")]),t._v(" utf-16码位(基本多文种平面)到辅助平面字符的扩展")]),t._v(" "),e("blockquote",[e("p",[t._v("在ES6之前， JS 的字符串以 16 位字符编码(UTF-16)为基础。每个 16 位序列(相当于2个字节)是一个编码单元(code unit)，可简称为码元，用于表示一个字符。字符串所有的属性与方法(如length属性与charAt() 方法等)都是基于16位序列")])]),t._v(" "),e("blockquote",[e("p",[t._v("最常用的Unicode字符使用16位序列编码字符，属于“基本多语种平面”(Basic Multilingual Plane BMP)，也称为“零断面”(plan 0)， 是Unicode中的一个编码区段，编码介于\\u0000~\\uFFFF之间。超过这个范围的码位则要归属于某个辅助平面或称为扩展平面(supplementary plane)，其中的码位仅用16位就无法表示了        为此，UTF-16引入了代理对(surrogate pairs)，规定用两个16位编码来表示一个码位。这意味着，字符串里的字符有两种：一种由一个码元（共 16 位）来表示BMP字符，另一种用两个码元（共 32 位）来表示辅助平面字符")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("let text = '?'\n\nconsole.log(text.length); //2\nconsole.log(/^.$/.test(text)); //false\nconsole.log(text.charAt(0)); //�\nconsole.log(text.charAt(1)); //�\nconsole.log(text.charCodeAt(0)); //55362\nconsole.log(text.charCodeAt(1)); //57271\n\n")])])]),e("blockquote",[e("p",[t._v("这个字?（jí）其实就是一个两个16位字符组成的字,基于16位字符串的属性与方法便失效了")])]),t._v(" "),e("h4",{attrs:{id:"codepointat-只接受编码单元的位置而非字符位置作为参数-返回给定位置对应的码位"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#codepointat-只接受编码单元的位置而非字符位置作为参数-返回给定位置对应的码位"}},[t._v("#")]),t._v(" codePointAt()  只接受编码单元的位置而非字符位置作为参数,返回给定位置对应的码位")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("let text = 'a?'\n\nconsole.log(text.charCodeAt(0)); //55362\nconsole.log(text.charCodeAt(1)); //57271\nconsole.log(text.charCodeAt(2)); //57271\n\nconsole.log(text.codePointAt(0)); //134071\nconsole.log(text.codePointAt(1)); //57271\nconsole.log(text.codePointAt(2)); //57271\n\n")])])]),e("blockquote",[e("p",[t._v("通过这个方法我们可以检测字符是不是32位的")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("function is32Bit(char){\n    return char.codePointAt(0) > 0xffff;\n    \n}\n\nconsole.log(is32Bit('?')); //ture\nconsole.log(is32Bit('a'));  //false\n\n")])])]),e("h4",{attrs:{id:"string-fromcodepoint-通过码位获得对应字符"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#string-fromcodepoint-通过码位获得对应字符"}},[t._v("#")]),t._v(" String.fromCodePoint()通过码位获得对应字符")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("  console.log(String.fromCodePoint(134071)); //?\n")])])]),e("h4",{attrs:{id:"normalize"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#normalize"}},[t._v("#")]),t._v(" normalize()")]),t._v(" "),e("blockquote",[e("p",[t._v("许多欧洲语言有语调符号和重音符号。为了表示它们，Unicode提供了两种方法。一种是直接提供带重音符号的字符，比如Ǒ（\\u01D1）。另一种是提供合成符号（combining character），即原字符与重音符号的合成，两个字符合成一个字符，比如O（\\u004F）和ˇ（\\u030C）合成Ǒ（\\u004F\\u030C）。\n这两种表示方法，在视觉和语义上都等价，但是JavaScript不能识别。")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("'\\u01D1'==='\\u004F\\u030C' //false\n\n'\\u01D1'.length // 1\n'\\u004F\\u030C'.length // 2\n'\\u01D1'.normalize() === '\\u004F\\u030C'.normalize() // true\n\n")])])]),e("ul",[e("li",[t._v("NFC，默认参数，表示“标准等价合成”（Normalization Form Canonical Composition），返回多个简单字符的合成字符。所谓“标准等价”指的是视觉和语义上的等价。")]),t._v(" "),e("li",[t._v("NFD，表示“标准等价分解”（Normalization Form Canonical Decomposition），即在标准等价的前提下，返回合成字符分解的多个简单字符。")]),t._v(" "),e("li",[t._v("NFKC，表示“兼容等价合成”（Normalization Form Compatibility Composition），返回合成字符。所谓“兼容等价”指的是语义上存在等价，但视觉上不等价，比如“囍”和“喜喜”。（这只是用来举例，normalize方法不能识别中文。）")]),t._v(" "),e("li",[t._v("NFKD，表示“兼容等价分解”（Normalization Form Compatibility Decomposition），即在兼容等价的前提下，返回合成字符分解的多个简单字符")])]),t._v(" "),e("h4",{attrs:{id:"正则表达式u修饰符"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#正则表达式u修饰符"}},[t._v("#")]),t._v(" 正则表达式u修饰符")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("let text = '?'\nconsole.log(/^.$/.test(text)); //false\nconsole.log(/^.$/u.test(text)); //true\n")])])]),e("h4",{attrs:{id:"计算码位的数量"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#计算码位的数量"}},[t._v("#")]),t._v(" 计算码位的数量")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('function codePointLength(text){\n    let result = text.match(/[\\s\\S]/gu);\n    return result ? result.length : 0;\n}\nconsole.log(codePointLength("123a")); //4\nconsole.log(codePointLength("?a")); //2\nconsole.log(codePointLength("?哦")); //2\n\n\n//emmmmm。运行效率蛮低，听说有更简单的，后面演示\n\n')])])]),e("h3",{attrs:{id:"字符串中子串的识别"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#字符串中子串的识别"}},[t._v("#")]),t._v(" 字符串中子串的识别")]),t._v(" "),e("h4",{attrs:{id:"includes-x-y-检测指定字符串返回boolean值-第二参数是开始位置-0开始数"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#includes-x-y-检测指定字符串返回boolean值-第二参数是开始位置-0开始数"}},[t._v("#")]),t._v(" includes(x,y)检测指定字符串返回boolean值，第二参数是开始位置(0开始数)")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("let text = \"adsdasdasgsgwefsfs\";\nlet subtext = 'asd';\nconsole.log(text.includes(subtext,4)) //true\nconsole.log(text.includes(subtext)) //true\nconsole.log(text.includes('sdadasda')) //false\n\n")])])]),e("h4",{attrs:{id:"startswith-x-y-和-endswith-x-y-检测字符串开头和结尾的是否与子串相匹配-第二参数是开始位置-0开始数"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#startswith-x-y-和-endswith-x-y-检测字符串开头和结尾的是否与子串相匹配-第二参数是开始位置-0开始数"}},[t._v("#")]),t._v(" startsWith(x,y) 和 endsWith(x,y) 检测字符串开头和结尾的是否与子串相匹配,第二参数是开始位置(0开始数)")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("let text = \"adsdasdasgsgwefsfs\";\nlet subtext1 = 'ads';\nlet subtext2 = 'sfs';\n\nconsole.log(text.startsWith('asd',4)) //true\nconsole.log(text.startsWith(subtext1)) //true\nconsole.log(text.startsWith('sdadasda')) //false\n\n\nconsole.log(text.endsWith('gsgwefsfs',18)) //true 以最后一个字母的位置为准\nconsole.log(text.endsWith(subtext2)) //true\nconsole.log(text.endsWith('sdadasda')) //false\n\n")])])]),e("h4",{attrs:{id:"repeat-接受一个number-即将字符重复的次数"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#repeat-接受一个number-即将字符重复的次数"}},[t._v("#")]),t._v(" repeat() 接受一个number,即将字符重复的次数")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("console.log('x'.repeat(6)); // xxxxxx\nconsole.log('ly'.repeat(3));  //lylyly\nconsole.log('爱'.repeat(2));  //爱爱\n\n")])])]),e("h3",{attrs:{id:"正则的语法变更-蛮头疼的-正则还是晕乎乎的"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#正则的语法变更-蛮头疼的-正则还是晕乎乎的"}},[t._v("#")]),t._v(" 正则的语法变更 （蛮头疼的,正则还是晕乎乎的）")]),t._v(" "),e("h4",{attrs:{id:"正则表达式y修饰符"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#正则表达式y修饰符"}},[t._v("#")]),t._v(" 正则表达式y修饰符")]),t._v(" "),e("blockquote",[e("p",[t._v("除了u 修饰符，ES6还为正则表达式添加了 y 修饰符，叫做“粘连”修饰符。y 修饰符的作用与 g 修饰符类似，也是全局匹配，后一次匹配都从上一次匹配成功的下一个位置开始。不同之处在于，g 修饰符只要剩余位置中存在匹配就可，而 y 修饰符确保匹配必须从剩余的第一个位置开始，这也就是“粘连”的含义，当为匹配到时，将会返回空，lastIndex将会置为0")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('var s = \'aaa_aa_a\';  \nvar r1 = /a+/g;  \nvar r2 = /a+/y;  \n  \nconsole.log(r1.exec(s)) //["aaa", index: 0, input: "aaa_aa_a"] console.log(r2.exec(s)) //["aaa", index: 0, input: "aaa_aa_a"]\nconsole.log(r1.lastIndex) //3\nconsole.log(r2.lastIndex) //3\n\n\nconsole.log(r1.exec(s)) //["aa", index: 4, input: "aaa_aa_a"]\nconsole.log(r2.exec(s)) //null  \nconsole.log(r1.lastIndex) //6\nconsole.log(r2.lastIndex) //0\n\n\n\nconsole.log(r1.exec(s)) //["a", index: 7, input: "aaa_aa_a"]\nconsole.log(r2.exec(s)) //["aaa", index: 0, input: "aaa_aa_a"] console.log(r1.lastIndex) //8\nconsole.log(r2.lastIndex) //3\n')])])]),e("blockquote",[e("p",[t._v("检测y修饰符是否存在")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("let pattern = /hello\\d/y;\n\nconsole.log(pattern.sticky) //true  谷歌浏览器下\n")])])]),e("h4",{attrs:{id:"正则表达式的复制"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#正则表达式的复制"}},[t._v("#")]),t._v(" 正则表达式的复制")]),t._v(" "),e("blockquote",[e("p",[t._v("es5 如下复制")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("var re1 = /ab/i\n    re2 = new RegExp(re1);\n    console.log(re1.construct === re2.construct) //true\n")])])]),e("blockquote",[e("p",[t._v("es6新增了可以添加传修饰符")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("var re1 = /ab/i\n    re2 = new RegExp(re1,'g');\n    console.log(re1.toString()) ///ab/i\n    console.log(re2.toString()) ///ab/g\n\n")])])]),e("h4",{attrs:{id:"flags属性"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#flags属性"}},[t._v("#")]),t._v(" flags属性")]),t._v(" "),e("blockquote",[e("p",[t._v("source获取正则表达式文本 flags获取其修饰符")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("let re = /ab/gi;\n\n\nconsole.log(re.source); //ab\nconsole.log(re.flags);  //gi\n\n")])])]),e("h3",{attrs:{id:"模板字面量"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#模板字面量"}},[t._v("#")]),t._v(" 模板字面量")]),t._v(" "),e("blockquote",[e("p",[t._v("JS 的字符串相对其他语言来说功能总是有限的，事实上，ES5中一直缺乏许多特性，如多行字符串、字符串格式化、HTML转义等。ES6通过模板字面量的方式进行了填补，模板字面量试着跳出JS已有的字符串体系，通过一些全新的方法来解决类似的问题")])]),t._v(" "),e("h4",{attrs:{id:"反引号"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#反引号"}},[t._v("#")]),t._v(" 反引号（``）")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("const name = 'ly';\nlet message = `${name},is a man`  //ly,is a man\nconsole.log(message);\n\n//${} 可以写变量  名叫字符串占位符\n\nconsole.log(`\\`hh\\``); //`hh`\n\n//es5 实现多行文本\nvar message = \" ly  \\n \\\n   love you\"\nconsole.log(message);\n\n//es6\n\nvar message = ` ly\n   love you`\nconsole.log(message); // ly\n                      // love you\n\n")])])]),e("h4",{attrs:{id:"字符串占位符-javascript表达式"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#字符串占位符-javascript表达式"}},[t._v("#")]),t._v(" 字符串占位符   ${javascript表达式}")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("let count = 15,\n    price = .5,\n    message = `${count} items cost $${(count*price).toFixed(1)}`;\n    console.log(message); //15 items cost $7.5\n\n")])])]),e("h4",{attrs:{id:"标签模板"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#标签模板"}},[t._v("#")]),t._v(" 标签模板")]),t._v(" "),e("blockquote",[e("p",[t._v("标签模板其实不是模板，而是函数调用的一种特殊形式。“标签”指的是函数，紧跟在后面的模板字符串就是它的参数")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("var a = 5;\nvar b = 10;\ntag `Hello ${a+b} world ${a*b}`;\n//这个标识名tag,它是一个函数。整个表达式的返回值，就是tag函数处理模板字符串之后的返回值。函数tag会依次接收到多个参数。\n")])])]),e("blockquote",[e("p",[t._v("tag函数的第一个参数是一个数组，该数组的成员时模板字符串中那些没有变量替换的部分，也就是说，变量替换只发生在数组的第一个成员和第二个成员之间，以此类推。tag函数的其他参数都是模板字符串各个变量被替换后的值，由于本例中，模板字符串含有两个变量，因此tag会接收到value1和value2两个参数。\ntag函数所有参数的实际值如下：\n——第一个参数：['Hello ',' world ','']\n——第二个参数：15\n——第三个参数：50\n也就是说tag函数实际上是以下面的形式调用的\ntag(['Hello ',' world ',''],15,50);\n我们可以按照需要编写tag 函数的代码。")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("var count = 5;\nvar price = 10;\n\nfunction tag(s,v1,v2,v3){\n    console.log(s[0]);\n    console.log(s[1]);\n    console.log(s[2]);\n    console.log(s);\n    console.log(v1);\n    console.log(v2);\n    return 'ok'\n}\ntag`q${count} items cost $${(count*price).toFixed(1)}.`;\n\n//VM173:5 \n//VM173:6  items cost $\n//VM173:7  .\n//VM173:8 5\n//VM173:9 50.0\n//ok\n\n")])])]),e("blockquote",[e("p",[t._v("标签函数的常用形式")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("function tag(literals,...substitutions){\n    //literals 值得是被${}隔开的字符\n    //substitutions，有几个${}就有几个这个\n}\n\n")])])]),e("blockquote",[e("p",[t._v("利用 literals.length-1 === substitutions.length,拼接字符串")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('function passthru(literals,...values){\n    var output ="";\n    for(var index = 0;index<values.length;index++){\n        output = literals[index]+values[index];\n    }\n    output+=literals[index];\n    return output;\n}\n\nlet count = 15,\n    price = .5,\n    message = passthru`${count} items cost $${(count*price).toFixed(1)}`;\n    console.log(message); //15 items cost $7.5\n\n')])])]),e("blockquote",[e("p",[t._v("what?这样做的意义是啥？")])]),t._v(" "),e("blockquote",[e("p",[t._v("emmm,过滤html字符串,还有一些转义字符的过滤")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('function SaferHTML(templateData){\n    var s = templateData[0];\n    var i;\n    for(i = 1;i<arguments.length;i++){\n        var arg = String(arguments[i]);\n\n        //sender里面可能有特殊字符，进行转义\n        s += arg.replace(/&/g,"&amp;")\n                .replace(/</g,"&lt;")\n                .replace(/>/g,"&gt;");\n        s += templateData[i];\n    }\n    console.log(i);//2，表示这个循环只执行了一次，因为templateData[0]="<p>",arguments这个数组只有${sender}这个元素，后面一长串字符都是templateData[2];\n    return s;\n}\nvar sender = \'<script>alert("abc")<\/script>\';\nvar message = SaferHTML`<p>${sender} has sent you a message.</p>`;\nconsole.log(message);\n')])])]),e("h4",{attrs:{id:"在模板字面量中使用原始值"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#在模板字面量中使用原始值"}},[t._v("#")]),t._v(" 在模板字面量中使用原始值")]),t._v(" "),e("blockquote",[e("p",[t._v("使用内建对象String.raw访问")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("\nlet ms1 = `ly\\n love you`\nlet ms2 = String.raw`ly\\n love you`\n\nconsole.log(ms1); //ly\n                  //love you\n\nconsole.log(ms2); // ly\\n love you\n\n\n")])])])])}),[],!1,null,null,null);a.default=n.exports}}]);