(window.webpackJsonp=window.webpackJsonp||[]).push([[52],{565:function(e,n,t){"use strict";t.r(n);var a=t(6),s=Object(a.a)({},(function(){var e=this,n=e.$createElement,t=e._self._c||n;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("p",[t("img",{attrs:{src:"http://upload-images.jianshu.io/upload_images/10843623-71a29ec16eb69664.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240",alt:"timg.jpg"}})]),e._v(" "),t("h3",{attrs:{id:"前言"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#前言"}},[e._v("#")]),e._v(" 前言")]),e._v(" "),t("blockquote",[t("p",[e._v("最近这两天有点不在状态，感觉有种无形的压力压在身上，变的异常的暴躁了，唉，前端这条路真的走对了吗？算了，敲代码吧。")])]),e._v(" "),t("h4",{attrs:{id:"类声明"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#类声明"}},[e._v("#")]),e._v(" 类声明")]),e._v(" "),t("blockquote",[t("p",[e._v("要声明一个类,首先使用 class 关键字，紧接着是类的名字，然后其他内部方法和属性类似于对象的字面量写法")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v(' class PersonClass{\n        //定义一个类似es5写法的构造函数，通过关键字constructor\n            constructor(name){\n                      this.name = name\n            }\n       //定义方法\n          sayName(){\n                  console.log(this.name);\n}\n}\nlet person = new PersonClass("ly");\nperson.sayName();\nconsole.log(person instanceof PersonClass);\nconsole.log(person instanceof Object);\n\nconsole.log(typeof PersonClass);\nconsole.log(typeof  PersonClass.prototype.sayName);\n')])])]),t("p",[t("img",{attrs:{src:"http://upload-images.jianshu.io/upload_images/10843623-83d30f20fab6f12f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240",alt:"a.png"}})]),e._v(" "),t("blockquote",[t("p",[e._v("es5 对应的等价代码")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('let PersonType2 = (function(){\n    "use strict"\n    const PersonType2 = function(name){\n        //确保通过关键字new调用该函数\n        if(typeof new.target === "undefined"){\n            throw new Error("必须通过new来创建")\n        }\n    }\n    Object.defineProperty(PersonType2.prototype,\'sayName\',{\n        value:function(){\n            //确保不通过关键字new调用该函数\n        if(typeof new.target !== "undefined"){\n            throw new Error("不能通过new来创建")\n        }\n        console.log(this.name)\n        },\n        enumerable:false,\n        writable:true,\n        configurable:true\n    })\n    return PersonType2;\n}())\n')])])]),t("h4",{attrs:{id:"类表达式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#类表达式"}},[e._v("#")]),e._v(" 类表达式")]),e._v(" "),t("blockquote",[t("p",[e._v("跟函数一样他也存在表达式写法，好像还很雷同")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v(' let PersonClass = class {\n        //定义一个类似es5写法的构造函数，通过关键字constructor\n            constructor(name){\n                      this.name = name\n            }\n       //定义方法\n          sayName(){\n                  console.log(this.name);\n}\n}\nlet person = new PersonClass("ly");\nperson.sayName();\nconsole.log(person instanceof PersonClass);\nconsole.log(person instanceof Object);\n\nconsole.log(typeof PersonClass);\nconsole.log(typeof  PersonClass.prototype.sayName);\n')])])]),t("blockquote",[t("p",[e._v("上述两种类的写法，它不会出现变量提升的现象，所以我们的那种写法，对结果没啥太大区别")])]),e._v(" "),t("h4",{attrs:{id:"类也将作为一等公民"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#类也将作为一等公民"}},[e._v("#")]),e._v(" 类也将作为一等公民")]),e._v(" "),t("blockquote",[t("p",[e._v("一等公民是指一个可以传入的函数，可以从函数返回，并且可以赋值给变量的值")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("//像这样的方式\nfunction createObject(classDef){\n      return new ClassDef();\n}\nlet objClass = createObject(class {\n      sayHi() {\n      console.log('hi');\n}\n})\n\n//函数表达式还有一种调用方式，就是通过立即调用类构造函数可以创建单例\n\nlet person = new class{\n      constructor(name){\n              this.name = name;  \n      }\n       sayName() {\n        console.log(this.name);\n}\n}('ly')\nperson.sayName() //ly\n")])])]),t("h3",{attrs:{id:"访问器属性"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#访问器属性"}},[e._v("#")]),e._v(" 访问器属性")]),e._v(" "),t("blockquote",[t("p",[e._v("类支持在构造函数下创建自己的属性，但是类也支持直接在原型上定义访问器的属性,通过 get 和 set 来获得值或者设置值")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("class Person {\n    constructor(name) {\n        this.name = name;\n    }\n    set ages(age) {\n        return this.age = age;\n    }\n    get ages() {\n        return this.age+10;\n    }\n}\n\nlet person = new Person('ly');\n\nperson.ages = 18\nconsole.log(person.ages);\nperson.agess = 18\nconsole.log(person.agess);\n\nvar descriptor = Object.getOwnPropertyDescriptor(Person.prototype,'ages');\nconsole.log(\"get\" in descriptor); //true\nconsole.log(\"set\" in descriptor);//true\nconsole.log(descriptor.enumerable); //false\n")])])]),t("h4",{attrs:{id:"生成器方法与类的结合"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#生成器方法与类的结合"}},[e._v("#")]),e._v(" 生成器方法与类的结合")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("class MyClass {\n    * createIterator() {\n        yield 1;\n        yield 2;\n        yield 1;\n    }\n}\nvar b = new MyClass()\nvar a = b.createIterator();\nconsole.log(a.next());\nconsole.log(a.next());\nconsole.log(a.next());\nconsole.log(a.next());\n")])])]),t("p",[t("img",{attrs:{src:"http://upload-images.jianshu.io/upload_images/10843623-bb30ba005f00fc95.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240",alt:"a.png"}})]),e._v(" "),t("h4",{attrs:{id:"我们可以通过-symbol-iterator-属性定义一个默认的类迭代器"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#我们可以通过-symbol-iterator-属性定义一个默认的类迭代器"}},[e._v("#")]),e._v(" 我们可以通过 Symbol.iterator 属性定义一个默认的类迭代器")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("class Collection {\n    constructor() {\n        this.items = []\n    }\n    *[Symbol.iterator]() {\n        yield * this.items.entries();\n    }\n}\nvar collection = new Collection();\n\ncollection.items.push(1)\ncollection.items.push(12)\ncollection.items.push(16)\n\nfor (const x of collection) {\n    console.log(x);\n}\n")])])]),t("p",[t("img",{attrs:{src:"http://upload-images.jianshu.io/upload_images/10843623-8e8e1426697003fe.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240",alt:"a.png"}})]),e._v(" "),t("h3",{attrs:{id:"静态成员"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#静态成员"}},[e._v("#")]),e._v(" 静态成员")]),e._v(" "),t("blockquote",[t("p",[e._v("es5 来模拟静态成员")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('function PersonType(name){\n    this.name = name;\n\n}\n\n//静态方法\nPersonType.create = function(name){\n    return new PersonType(name)\n}\n\n//实例方法\nPersonType.prototype.sayName = function(){\n    console.log(this.name);\n}\n\nvar person = PersonType.create("ly");\nperson.name = "li"\nconsole.log(person); //ly  （不是很懂静态成员是干嘛的，就是为了让构造函数也能像普通函数一样挂在函数吗？）\n')])])]),t("blockquote",[t("p",[e._v("在 es 可以通过 static 来创建静态成员")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("class PersonClass {\n    constructor(name){\n        this.name = name;\n    }\n    sayName(){\n        console.log(\"hi\")\n    }\n\n    static create(name){\n        return new PersonClass(name)\n    }\n}\n\nlet person = PersonClass.create('ly');\n\nconsole.log(person.name); //ly\n")])])]),t("h3",{attrs:{id:"继承与派生类"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#继承与派生类"}},[e._v("#")]),e._v(" 继承与派生类")]),e._v(" "),t("blockquote",[t("p",[e._v("在 es6 之前继承需要这么长的代码，而且 haibuyi")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("function Reactangle(length,width){\n    this.length = length;\n     this.width = width;\n}\n\nReactangle.prototype.getArea = function(){\n    return this.length*this.width;\n}\n\nfunction Square(length){\n    Reactangle.call(this,length,length)\n}\n\nSquare.prototype = Object.create(Reactangle.prototype,{\n    constructor:{\n        value:Square,\n        enumerable:true,\n        writeable:true,\n        configurable:true\n    }\n})\n\nvar square = new Square(4);\n\nconsole.log(square.getArea()); //16\nconsole.log(square instanceof Square);//true\nconsole.log(square instanceof Reactangle);//true\n")])])]),t("blockquote",[t("p",[e._v("这样的类继承更加 清晰")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("class Reactangle {\n    constructor(length, width) {\n        this.length = length;\n        this.width = width;\n        console.log(this.length,this.width);\n    }\n    getArea() {\n\n        return this.length * this.width\n    }\n}\nclass Square extends Reactangle {\n    constructor(length) {\n\n        super(length, length)\n    }\n}\n\nvar square = new Square(3);\n\nconsole.log(square.getArea()); //9\nconsole.log(square instanceof Square); //true\n")])])]),t("blockquote",[t("p",[e._v("这是 super 的默认是设置")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("class Squery extends Reactangle {\n\n}\n\n//等价于\n\nclass Square extends Reactangle {\n    constructor(...args){\n        super(...args);\n    }\n}\n")])])]),t("h4",{attrs:{id:"类方法遮蔽"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#类方法遮蔽"}},[e._v("#")]),e._v(" 类方法遮蔽")]),e._v(" "),t("blockquote",[t("p",[e._v("派生类中的方法总会覆盖基类中的同名方法。这种覆盖只是屏蔽")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("class Reactangle {\n    constructor(length, width) {\n        this.length = length;\n        this.width = width;\n        console.log(this.length,this.width);\n    }\n    getArea() {\n\n        return this.length * this.width\n    }\n}\nclass Square extends Reactangle {\n     getArea() {\n         return this.length*this.length;\n     }\n}\n")])])]),t("blockquote",[t("p",[e._v("我们也可以屏蔽之后在调用")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("class Reactangle {\n    constructor(length, width) {\n        this.length = length;\n        this.width = width;\n        console.log(this.length,this.width);\n    }\n    getArea() {\n        return this.length * this.width\n    }\n}\nclass Square extends Reactangle {\n     getArea() {\n         return super.getArea();\n     }\n}\n\nvar square = new Square(3,3);\n\nconsole.log(square.getArea()); //9\nconsole.log(square instanceof Square); //true\n")])])]),t("h3",{attrs:{id:"静态成员继承"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#静态成员继承"}},[e._v("#")]),e._v(" 静态成员继承")]),e._v(" "),t("blockquote",[t("p",[e._v("通过 static 创建的静态成员,静态变量不能被子类继承")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("class Reactangle {\n    constructor(length, width) {\n        this.length = length;\n        this.width = width;\n        console.log(this.length,this.width);\n    }\n    getArea() {\n\n        return this.length * this.width\n    }\n\n    static create(length,width){\n        return new Reactangle(length,width)\n    }\n}\nclass Square extends Reactangle {\n     getArea() {\n         return super.getArea();\n     }\n}\n\nvar square = Square.create(3,4);\n\nconsole.log(square.getArea()); //9\nconsole.log(square instanceof Square); //true\n")])])]),t("blockquote",[t("p",[e._v("类相当于实例的原型， 所有在类中定义的方法， 都会被实例继承。 如果在一个方法前， 加上 static 关键字， 就表示该方法不会被实例继承， 而是直接通过类来调用， 这就称为“ 静态方法” (好像理解了点)")])]),e._v(" "),t("h3",{attrs:{id:"派生自表达式的类"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#派生自表达式的类"}},[e._v("#")]),e._v(" 派生自表达式的类")]),e._v(" "),t("blockquote",[t("p",[e._v("只要一个函数具有[Constuctor]属性和原型")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("function Reactangle(length,length){\n    this.length = length;\n    this.width  = width;\n\n}\n\nReactangle.prototype.getArea = function(){\n    return this.length*this.width\n}\n\nclass Square extends Reactangle {\n     constructor (length) {\n         super(length,length)\n     }\n}\n\nvar square = new Square(3);\n\nconsole.log(square.getArea()); //9\nconsole.log(square instanceof Square); //true\n")])])]),t("h3",{attrs:{id:"继承的高级用法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#继承的高级用法"}},[e._v("#")]),e._v(" 继承的高级用法")]),e._v(" "),t("blockquote",[t("p",[e._v("下面的栗子可以动态确定使用那个基类，更好的辅助开发")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('let SerializableMixin = {\n    serialize(){\n        return JSON.stringify(this)\n    }\n}\n\nlet AreaMixin = {\n    getArea() {\n        return this.length*this.width;\n    }\n}\n\n\nfunction mixin(...mixins){\n    var base = function(){};\n    Object.assign(base.prototype,...mixins);\n    return base;\n}\n\nclass Square extends mixin (AreaMixin,SerializableMixin) {\n      constructor (length){\n          super();\n          this.length = length;\n          this.width = length;\n      }\n}\n\nvar x = new Square(3)\nconsole.log(x.getArea())  //9\nconsole.log(x.serialize()) //{"length":3,"width":3}\n')])])]),t("h3",{attrs:{id:"类的-symbol-species-属性"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#类的-symbol-species-属性"}},[e._v("#")]),e._v(" 类的 Symbol.species 属性")]),e._v(" "),t("blockquote",[t("p",[e._v("Symbol.species 是指定一个构造函数创建派生对象的函数值属性,比如当我们继承一个 Array 时，我们调用其方法产生的对象将不再是原始的类而是派生出来的类，比如")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("class MyArray extends Array {\n\n}\n\nlet items = new MyArray(1,3,4,5),\n    subitems = items.map(item => item*2);\n\nconsole.log(items instanceof MyArray); //true\nconsole.log(subitems instanceof MyArray); //true\nconsole.log(items instanceof Array);  //true\nconsole.log(subitems instanceof Array); //true\n")])])]),t("blockquote",[t("p",[e._v("但是实际上也不是这么一回事，于是我加了这段代码")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("class MyArray extends Array {\n    static get [Symbol.species](){\n        return RegExp;\n    }\n}\n\nlet items = new MyArray(1,3,4,5),\n    subitems = items.map(item => item*2);\n\nconsole.log(items instanceof MyArray); //true\nconsole.log(subitems instanceof MyArray); //false\nconsole.log(items instanceof Array);  //true\nconsole.log(subitems instanceof Array); //false\n")])])]),t("blockquote",[t("p",[e._v("mdn 的解释一下代码参考下")])]),e._v(" "),t("blockquote",[t("p",[e._v("你可能想在扩展数组类 MyArray 上返回 Array 对象。 例如，当使用例如 map() 这样的方法返回默认的构造函数时，你希望这些方法能够返回父级的 Array 对象，以取代 MyArray 对象。Symbol.species 允许你这么做")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("class MyArray extends Array {\n    // 覆盖 species 到父级的 Array 构造函数上\n    static get [Symbol.species]() { return Array; }\n  }\n  var a = new MyArray(1,2,3);\n  var mapped = a.map(x => x * x);\n\n  console.log(mapped instanceof MyArray); // false\n  console.log(mapped instanceof Array);   // true\n")])])]),t("blockquote",[t("p",[e._v("但是即使不这么做我也是可以返回他的父级方法，有点鸡肋？ 再说")])]),e._v(" "),t("h3",{attrs:{id:"在累的构造函数使用-new-target"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#在累的构造函数使用-new-target"}},[e._v("#")]),e._v(" 在累的构造函数使用 new.target")]),e._v(" "),t("blockquote",[t("p",[e._v("之前在构造函数如果要求必须通过 new 来创建是这样写的")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("function Add(name){\n    console.log(new.target=== Add) //true\n    if(typeof new.target==\"undefined\"){\n        throw new Error('必须通过new创建')\n    }\n    this.name = name;\n}\n\nvar a = new Add('ly');\n")])])]),t("blockquote",[t("p",[e._v("现在可以怎么写")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("class Add {\n    constructor(name){\n        this.name = name;\n        console.log(new.target=== Add) //true\n    }\n}\n\nvar a = new Add('ly');\n")])])]),t("blockquote",[t("p",[e._v("构造函数不通过 new 创建的实例，new.target 为 undefined")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("function Add(name){\n    console.log(new.target) //true\n    if(typeof new.target==\"undefined\"){\n        throw new Error('必须通过new创建')\n    }\n    this.name = name;\n}\n\nvar a =Add('ly');\n")])])]),t("blockquote",[t("p",[e._v("类则是无论如何都有值，因为必须 new 啊 不然报错")])]),e._v(" "),t("blockquote",[t("p",[e._v("我们可以用这样的方式定义基类，基类不可被创建，只能被继承")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("class Add {\n    constructor(name){\n        if(new.target===Add){\n            throw new Error('基类不可被继承')\n        }\n        this.name = name;\n    }\n}\nclass SubAdd extends Add {\n    constructor(name){\n        super(name)\n\n    }\n}\n// var a = new Add('ly'); //报错   基类不可被继承\n\nvar b= new SubAdd('hh')\n")])])])])}),[],!1,null,null,null);n.default=s.exports}}]);