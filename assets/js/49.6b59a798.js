(window.webpackJsonp=window.webpackJsonp||[]).push([[49],{566:function(n,e,t){"use strict";t.r(e);var a=t(6),s=Object(a.a)({},(function(){var n=this,e=n.$createElement,t=n._self._c||e;return t("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[t("p",[t("img",{attrs:{src:"http://upload-images.jianshu.io/upload_images/10843623-f6bc1326e758c851.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240",alt:"i.jpg"}})]),n._v(" "),t("h2",{attrs:{id:"前言"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#前言"}},[n._v("#")]),n._v(" 前言")]),n._v(" "),t("blockquote",[t("p",[n._v("杭州这周温度达到-5度了，温度下降的蛮快，年会排舞感觉好悬啊，不知到能拍出啥道道来,现在唯一的心愿就是，早点回家，冷也阻止不了我回家的脚步，嗯哼。")])]),n._v(" "),t("blockquote",[t("p",[n._v("我的博客地址 ：http://www.aymfx.cn/")])]),n._v(" "),t("h3",{attrs:{id:"引子"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#引子"}},[n._v("#")]),n._v(" 引子")]),n._v(" "),t("blockquote",[t("p",[n._v("ES6函数的改变不算太大，都是一些其他语言早就有的功能，而Javascript一直比较欠缺的，比如函数参数默认值，任意参数的表示法，最大的变化应该是支持箭头函数(其他语言称之为LAMBDA表达式)，一种对匿名函数的一种简写方式")])]),n._v(" "),t("h4",{attrs:{id:"函数形参的默认值"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#函数形参的默认值"}},[n._v("#")]),n._v(" 函数形参的默认值")]),n._v(" "),t("blockquote",[t("p",[n._v("es5 模拟默认参数")])]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("function sendAjax(url,timeout,callback){\n    timeout = timeout || 2000;\n    callback = callback || $.noop(); //默认参数\n    \n    $.ajax(url).done(function(){\n        setTimeout(callback,timeout)\n    })\n    \n}\n")])])]),t("blockquote",[t("p",[n._v("上面的赋值操作会存在问题，你懂的，所以引入了es6的默认参数")])]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("\nfunction add(a=200,b=2){\n    return a+b;\n}\n\nconsole.log(add()); //202\nconsole.log(add(2)); //4\n\n\nconsole.log(add(null,2)); //2  null是合法值 被当成0\nconsole.log(add(undefined,2)); //202\n\n\n")])])]),t("h4",{attrs:{id:"默认参数对arguments对象的影响"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#默认参数对arguments对象的影响"}},[n._v("#")]),n._v(" 默认参数对arguments对象的影响")]),n._v(" "),t("blockquote",[t("p",[n._v("非严格模式下")])]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("function temp(first,second){\n    console.log(first=== arguments[0]);\n    console.log(second=== arguments[1]);\n    first = 'c';\n    second = 'd'\n    console.log(first=== arguments[0]);\n    console.log(second=== arguments[1]);\n}\n\ntemp('a','b')\n\n\n//true\n//VM264:3 true\n//VM264:6 true\n//VM264:7 true\n\n\n")])])]),t("blockquote",[t("p",[n._v("严格模式下")])]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("function temp(first,second){\n    'use strict'\n    console.log(first=== arguments[0]);\n    console.log(second=== arguments[1]);\n    first = 'c';\n    second = 'd'\n    console.log(first=== arguments[0]);\n    console.log(second=== arguments[1]);\n}\n\ntemp('a','b')\n\n\n//true\n//VM264:3 true\n//VM264:6 false\n//VM264:7 false\n\n")])])]),t("blockquote",[t("p",[n._v("非严格模式下，参数与argument的值保持一致,严格模式下arguments与传进来的初始参数保持一致，看看es6默认值存在的话")])]),n._v(" "),t("blockquote",[t("p",[n._v("非严格模式下")])]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("function temp(first,second='b'){\n    console.log(arguments.length)\n    console.log(first=== arguments[0]);\n    console.log(second=== arguments[1]);\n    first = 'c';\n    second = 'b'\n    console.log(first=== arguments[0]);\n    console.log(second=== arguments[1]);\n}\n\ntemp('a')\n\n//1\n//true\n//VM264:3 false\n//VM264:6 false\n//VM264:7 false\n\n\n")])])]),t("blockquote",[t("p",[n._v("严格模式下")])]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("function temp(first,second='b'){\n    'use strict'\n    console.log(arguments.length)\n    console.log(first=== arguments[0]);\n    console.log(second=== arguments[1]);\n    first = 'c';\n    second = 'd'\n    console.log(first=== arguments[0]);\n    console.log(second=== arguments[1]);\n}\n\ntemp('a')\n\n// Illegal 'use strict' directive in function with non-simple parameter list\n\n//hhhhhhhhhhhh,不能用，尴尬\n\n")])])]),t("h4",{attrs:{id:"默认参数表达式-可以传函数"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#默认参数表达式-可以传函数"}},[n._v("#")]),n._v(" 默认参数表达式,可以传函数")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("function getValue(){\n    return 5;\n}\n\nfunction add(first,second=getValue()){\n    return first+second;\n}\n\n\nconsole.log(add(1,2)); //3\nconsole.log(add(10));  //15\n\n")])])]),t("blockquote",[t("p",[n._v("可以将先前定义好的形参当默认值")])]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("\nfunction add(first,second=first){\n    return first+second;\n}\n\nconsole.log(add(1,2)); //3\nconsole.log(add(10));  //20\n\n反之不行哈\n\nfunction add(first=second,second){\n    return first+second;\n}\n\nconsole.log(add(1,2)); //3\nconsole.log(add(undefined,10));  //second is not defined\n\n//这就是所谓的临时死区TDZ，未初始化之前不可被引用\n\n")])])]),t("h4",{attrs:{id:"不定参数-keys"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#不定参数-keys"}},[n._v("#")]),n._v(" 不定参数 （...keys）")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("//模仿Underscore.js pick()方法\n\nfunction pick(object,...keys){\n    console.log(arguments.length); //3\n    let result = Object.create(null);\n    for(let i=0,len=keys.length;i<len;i++){\n        result[keys[i]]= object[keys[i]]\n    }\n    \n    return result;\n    \n}\n\n\nlet person = pick({name:'ly',age:'18',sex:'mael'},'age','sex'); \n\nconsole.log(person.name); //undefind\nconsole.log(person.age); //18\nconsole.log(person.sex); //mael\n")])])]),t("blockquote",[t("p",[n._v("不定参数的要求")])]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("function pick(obj,...keys,last){} //报错，不定参数必须放在最后后面\n\n//不定参数不能用于对象字面量setter之中\n\nlet object = {\n    set name(...values){\n        //执行逻辑\n    }\n}\n\n")])])]),t("h4",{attrs:{id:"function-构造函数功能增强-可以使用默认参数和不定参数"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#function-构造函数功能增强-可以使用默认参数和不定参数"}},[n._v("#")]),n._v(" Function 构造函数功能增强 可以使用默认参数和不定参数")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("const add = new Function('first','second = first','return first+second')\n\nconsole.log(add(1,2),add(1))  //3 2\n\n\nvar pick = new Function(\"...args\",\"return args[0]\")\n\nconsole.log(pick(1,2));  //1\n\n\n")])])]),t("h4",{attrs:{id:"展开运算符"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#展开运算符"}},[n._v("#")]),n._v(" 展开运算符")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("//之前求最大值的时候\n\nlet values = [25,100,75,56];\n\nconsole.log(Math.max.apply(this,values));  //100\n\n//有点麻烦，但是用展开运算符的话\n\nconsole.log(Math.max(...values)); //100\n\n//开不开心，我们可以拿其他值和数组值比较\n\nconsole.log(Math.max(...values,200)); //200\n\n")])])]),t("h4",{attrs:{id:"函数中可以获取函数名称的的属性-name"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#函数中可以获取函数名称的的属性-name"}},[n._v("#")]),n._v(" 函数中可以获取函数名称的的属性 name")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v('var func1 = function () {};\n// ES5\nfunc1.name // ""\n// ES6\nfunc1.name // "func1"\n//上面代码中，变量func1等于一个匿名函数， ES5 和 ES6 的name属性返回的值不一样。\n//如果将一个具名函数赋值给一个变量，则 ES5 和 ES6 的name属性都返回这个具名函数原本的名字。\nconst bar = function baz() {};\n// ES5\nbar.name // "baz"\n// ES6\nbar.name // "baz"\n//Function构造函数返回的函数实例，name属性的值为 “anonymous” 。\n(new Function).name // "anonymous"\n//bind返回的函数，name属性值会加上 “bound ” 前缀。\nfunction foo() {};\nfoo.bind({}).name // "bound foo"\n(function(){}).bind({}).name // "bound "\n\n\n\n//还有几个es6的情况\n\nvar dosomething = function(){}\n\nconsole.log(dosomething.bind().name);  //bound dosomething\nconsole.log((new Function()).name);    //anonymous\n\n')])])]),t("h4",{attrs:{id:"明确函数的多重用途"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#明确函数的多重用途"}},[n._v("#")]),n._v(" 明确函数的多重用途")]),n._v(" "),t("blockquote",[t("p",[n._v("js函数有两种内部方式 [[Call]]和[[Construct]],当通过new关键字调用函数时，执行的是[[Construct]]函数,他负责创建一个通常被称作实例的新对象，然后再执行函数体,将this绑定到实例上;如果不同过new则执行[[Call]]函数,从而直接执行代码中的函数体")])]),n._v(" "),t("h4",{attrs:{id:"es5判断函数被调用的方法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#es5判断函数被调用的方法"}},[n._v("#")]),n._v(" es5判断函数被调用的方法")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v('function Person(name){\n    if(this instanceof Person){\n        this.name = name;\n    } else{\n        throw new Error(\'必须new才行，嘿嘿\')\n    }\n}\n\nvar person = new Person("ly"); //\nvar notperson =Person("ll"); // 必须new才行，嘿嘿\n\n//但是可以蒙混过关\n\nvar notperson =Person.call(peson,"ll"); //\n\n\n')])])]),t("h4",{attrs:{id:"new-target-精准判断"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#new-target-精准判断"}},[n._v("#")]),n._v(" new.target 精准判断")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("function Person(name){\n    if(typeof new.target !== 'undefined'){\n        this.name = name;\n    } else{\n        throw new Error('必须new才行，嘿嘿')\n    }\n}\n\nvar person = new Person(\"ly\"); //\nvar notperson =Person.call(person,\"ll\"); //\n")])])]),t("h4",{attrs:{id:"块级作用域"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#块级作用域"}},[n._v("#")]),n._v(" 块级作用域")]),n._v(" "),t("blockquote",[t("p",[n._v("在es5的时代，当启用严格模式时，下列代码会报错,es6则不会,因为产生了块级作用域，该函数可以在这个if条件语句内部使用，外部依旧是undefined")])]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v(' "use strict"\n if(true){\n    console.log(typeof add); //function\n    function add(a,b){\n        return a+b;\n    }\n }\n \n console.log(typeof add);  //undefined\n\n')])])]),t("blockquote",[t("p",[n._v("但是在非严格模式下，该函数还是会被提升到全局作用域顶部")])]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v(" if(true){\n    console.log(typeof add); //function\n    function add(a,b){\n        return a+b;\n    }\n }\n \n console.log(typeof add);  //function\n\n\n")])])]),t("h3",{attrs:{id:"重要改变-箭头函数"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#重要改变-箭头函数"}},[n._v("#")]),n._v(" 重要改变 箭头函数")]),n._v(" "),t("blockquote",[t("p",[n._v("一些好玩的改变（兴奋状）")])]),n._v(" "),t("ul",[t("li",[n._v("没有this,spuer,arguments和new.target绑定")]),n._v(" "),t("li",[n._v("不能通过new关键字调用")]),n._v(" "),t("li",[n._v("没有原型")]),n._v(" "),t("li",[n._v("不可以改变this的绑定")]),n._v(" "),t("li",[n._v("不支持arguments对象")]),n._v(" "),t("li",[n._v("不支持重复的命名参数")])]),n._v(" "),t("h4",{attrs:{id:"箭头函数的语法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#箭头函数的语法"}},[n._v("#")]),n._v(" 箭头函数的语法")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("let add = (a,b) => a+b;\n\n//实际类似于\n\nlet add = function(a,b){return a+b}\n\n\n//当箭头函数只有一个参数时，不需要括号\n\nlet reflrct = value => value\n\n//类似于\n\nlet reflrct = function(value){return value}\n\n//不写参数时要加括号\n\nlet name = () => 'ly';\n\n\n//类似于\n\nlet name = function(){return 'ly'}\n\n\n//如果需要写复杂的函数体，则必须这样写\n\nlet getName = (fisrtName,secondName) => {\n    return firstName+' '+ secondName;\n}\n\n//类似于\n\nlet getName = function(fisrtName,secondName){\n    return firstName+' '+ secondName;\n}\n\n//如果想反回一个字面量对象则需要这样写\n\nlet person = () => ({\n    name:'ly',\n    age:18\n})\n\n//类似于\n\nlet person = function(){\n    return {\n    name:'ly',\n    age:18\n}\n}\n\n//创建一个立即表达函数\n\nlet person = ((name) => ({getName:() => name}))('ly')\n\n//自己还原下看看，嘿嘿\n\n\n")])])]),t("h4",{attrs:{id:"箭头函数没有this绑定"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#箭头函数没有this绑定"}},[n._v("#")]),n._v(" 箭头函数没有this绑定")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("let PageHandler = {\n     id:'13579',\n     init:function(){\n         document.addEventListener('click',function(event){\n             this.doSomething(event.type)  //会报错\n         })\n     },\n     doSomething:function(type){\n         console.log(type);\n     }\n}\n\n")])])]),t("blockquote",[t("p",[n._v("es5的做法，将会这么做")])]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("let PageHandler = {\n     id:'13579',\n     init:function(){\n         document.addEventListener('click',(function(event){\n             this.doSomething(event.type)  \n         }).bind(this))\n     },\n     doSomething:function(type){\n         console.log(type);\n     }\n}\n\n\n\n")])])]),t("blockquote",[t("p",[n._v("但是有了箭头函数的话，就帅多了")])]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("let PageHandler = {\n     id:'13579',\n     init:function(){\n         document.addEventListener('click',event => this.doSomething(event.type) \n         )\n     },\n     doSomething:function(type){\n         console.log(type);\n     }\n}\n")])])]),t("blockquote",[t("p",[n._v("因为箭头函数是没有this的,所以在处理的过程中，它里面的this取决函数外部非箭头函数的this值")])]),n._v(" "),t("h3",{attrs:{id:"箭头函数不存在arguments绑定所以可以这么操作"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#箭头函数不存在arguments绑定所以可以这么操作"}},[n._v("#")]),n._v(" 箭头函数不存在arguments绑定所以可以这么操作")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v(" function outer(){\n     return () => arguments[0];\n }\n \n let inner = outer(18)\n \n  console.log(inner()); //18  就是这么骚气，直接访问箭头函数体外函数的arguments\n\n")])])]),t("blockquote",[t("p",[n._v("call(),bind(),apply() 都是可以用的，但是改变不了this的值的哈")])]),n._v(" "),t("h4",{attrs:{id:"尾调用的优化-tail-call"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#尾调用的优化-tail-call"}},[n._v("#")]),n._v(" 尾调用的优化(Tail Call)")]),n._v(" "),t("blockquote",[t("p",[n._v("尾调用指的是函数做为另一个函数最后一条语句被调用,它不会在调用栈上增加新的堆栈帧，而是直接更新调用栈，调用栈所占空间始终是常量，节省了内存，避免了爆栈的可能性,但是es5存在调用栈变得过大则会造成程序问题")])]),n._v(" "),t("blockquote",[t("p",[n._v("尾调用实例")])]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("\n function add(a,b){\n     \n }\n \n function max(a,b,c,d){\n \n    //......\n     return add(a,c);\n     \n }\n\n")])])]),t("blockquote",[t("p",[n._v("优化需要满足以下条件,尾调用才不会创建新栈帧,而是清除并重用当前栈帧")])]),n._v(" "),t("ul",[t("li",[n._v("尾调用不访问当前栈的变量(不形成闭包)")]),n._v(" "),t("li",[n._v("尾调用是函数内部的最后一句")]),n._v(" "),t("li",[n._v("尾调用的结果将作为函数值返回 (必须有return fn())")])]),n._v(" "),t("blockquote",[t("p",[n._v("使用场景 尾递归")])]),n._v(" "),t("blockquote",[t("p",[n._v("错误方式")])]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("console.time('testForEach');\nfunction factorial(n) {\n    if(n<=1){\n        return 1\n    } else {\n        return n*factorial(n-1)  //如果n很大，在不断递归的情况下，会栈溢出，这也不是尾递归\n    }\n}\nvar a =factorial(5000);\nconsole.log(a); \nconsole.timeEnd('testForEach'); // 1.55322265625ms\n\n\n")])])]),t("blockquote",[t("p",[n._v("正确写法")])]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("console.time('testForEach');\nfunction factorial(n,p=1) {\n    if(n<=1){\n        return 1*p;\n    } else {\n        let result = p*n;\n        return factorial(n-1,result)  \n}\n}\nfactorial(5000);\nconsole.timeEnd('testForEach'); //0.492919921875ms    测 了10000 居然栈溢出  搞不懂\n\n")])])])])}),[],!1,null,null,null);e.default=s.exports}}]);