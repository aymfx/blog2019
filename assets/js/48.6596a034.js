(window.webpackJsonp=window.webpackJsonp||[]).push([[48],{562:function(e,t,n){"use strict";n.r(t);var l=n(6),o=Object(l.a)({},(function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("h3",{attrs:{id:"前言"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#前言"}},[e._v("#")]),e._v(" 前言")]),e._v(" "),n("blockquote",[n("p",[e._v("突然就断网了，hhhh")])]),e._v(" "),n("blockquote",[n("p",[e._v("我的博客地址 ：http://www.aymfx.cn/")])]),e._v(" "),n("h4",{attrs:{id:"symbo"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#symbo"}},[e._v("#")]),e._v(" symbo")]),e._v(" "),n("blockquote",[n("p",[e._v("这是新的原始类型，一般是用于非字符串属性名称，利用其特性创建私有的变量")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('var firstname = Symbol(),\n    person = {};\n\nperson[firstname] = "ly";\n\nconsole.log(person[firstname]); //ly\n\n')])])]),n("blockquote",[n("p",[e._v("添加描述")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("var firstname = Symbol('liuyang'),\n    person = {};\n\nperson[firstname] = \"ly\";\n\nconsole.log('liuyang' in person); //false\nconsole.log(person[firstname]); //ly\n\nconsole.log(firstname) //Symbol(liuyang)\n\n")])])]),n("blockquote",[n("p",[e._v("可以通过 typeof 来识别")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('let symbol = Symbol("test");\n\nconsole.log(typeof symbol)  //symbol\n\n')])])]),n("h4",{attrs:{id:"symbol-使用方式"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#symbol-使用方式"}},[e._v("#")]),e._v(" Symbol 使用方式")]),e._v(" "),n("blockquote",[n("p",[e._v("可用于计算对象字面量属性名，Object.defineProperty()方法和 Object.defineProperties()方法的调用过程中")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("let firstname = Symbol(\"first name\")\n\n//可用于计算对象字面量属性名\n\nlet person = {\n    [firstname]:'nicholas'\n}\n\n//将属性设置为只读\n\nObject.defineProperty(person,firstname,{writeable:false});\n\nlet lastName = Symbol('last name');\n\nObject.defineProperties(person,{\n    [lastName]:{\n        value:'zhaosi',\n        writeable:false\n    }\n})\n\nconsole.log(person[firstname],person[lastName]);  //nicholas zhaosi\n\n")])])]),n("h4",{attrs:{id:"symbol-共享体系"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#symbol-共享体系"}},[e._v("#")]),e._v(" Symbol 共享体系")]),e._v(" "),n("blockquote",[n("p",[e._v("当你的应用有两种不同的对象类型，但是你希望他们共享一个 Symbol,你可以使用 Symbol 注册表，通过 for 方法来操作")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("let uid = Symbol.for('i am Object property');\n\nlet obj1 = {\n    [uid] :'ly'\n}\n\nlet uid2 = Symbol.for('i am Object property');\n\nlet obj2 = {\n    [uid2] : 'i am Object property'\n}\n\nconsole.log(uid===uid2); true\n\nconsole.log(obj1[uid],obj2[uid2]); ly i am Object property\n\nconsole.log(uid2) Symbol(i am Object property)\n\n//通过Symbol.keyFor(),来查找Symbol的键\n\n\nconsole.log(Symbol.keyFor(uid),Symbol.keyFor(uid2))  //i am Object property i am Object property\n\n\nlet uid3 = Symbol('uid3')\n\nconsole.log(Symbol.keyFor(uid3))  //undefined   ,因为没使用for方法进行注册\n\n")])])]),n("h4",{attrs:{id:"symbol-的类型强制转换"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#symbol-的类型强制转换"}},[e._v("#")]),e._v(" Symbol 的类型强制转换")]),e._v(" "),n("blockquote",[n("p",[e._v("似乎 Symbol 不能与其他的类型发生强制转换的操作，我们只能用 String 惊醒字符串的输出")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("let uid = Symbol('useful message'),\n    desc = String(uid);\n\nconsole.log(desc); //Symbol(useful message)\n\n\n//不能进行字符串的拼接\nlet uid = Symbol('useful message');\n\nlet string = uid+'!'  //报错  Cannot convert a Symbol value to a string\n\n\n//不能进行运算\n\nlet uid = Symbol('useful message');\n\nlet string = uid/1; //Cannot convert a Symbol value to a number\n\n//逻辑操作符可以,等价为布尔值true\n\n\nlet uid = Symbol('useful message');\n\nlet s = uid ? '对的': '错的';\n\nconsole.log(s) //对的\n\n\n")])])]),n("h4",{attrs:{id:"symbol-的检索属性"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#symbol-的检索属性"}},[e._v("#")]),e._v(" Symbol 的检索属性")]),e._v(" "),n("blockquote",[n("p",[e._v("Object.keys()方法，将会返回的是可枚举的属性名,Object.getOwnPropertyNames()方法将会枚举的可举性，将会全部返回,但是他们不支持枚举 Symbol 属性,es6 提供了 Object.getOwnPropertySymbols()方法枚举包含的 Symbol 的自有属性数组")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("let uid = Symbol('a'),\n    uid2 = Symbol('a2'),\n    object = {\n        [uid]:'12345',\n        [uid2]:'35487',\n        'hh':\"我应该排除在外的\"\n    };\n\nlet symbols = Object.getOwnPropertySymbols(object);\n\nconsole.log(symbols); // [Symbol(a), Symbol(a2)]\nconsole.log(symbols[0]);// Symbol(a)\nconsole.log(object[symbols[0]]);  //12345\n\n")])])]),n("h4",{attrs:{id:"通过-well-known-symbol-暴露内部操作"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#通过-well-known-symbol-暴露内部操作"}},[e._v("#")]),e._v(" 通过 well-known Symbol 暴露内部操作")]),e._v(" "),n("blockquote",[n("p",[e._v("除了自己创建的 symbol，JavaScript 还内建了一些在 ECMAScript 5 之前没有暴露给开发者的 symbol，它们代表了内部语言行为。它们可以使用以下属性访问：")])]),e._v(" "),n("h4",{attrs:{id:"迭代-symbols"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#迭代-symbols"}},[e._v("#")]),e._v(" 迭代 symbols")]),e._v(" "),n("ul",[n("li",[e._v("Symbol.iterator")])]),e._v(" "),n("blockquote",[n("p",[e._v("一个返回一个对象默认迭代器的方法。使用 for...of。")])]),e._v(" "),n("ul",[n("li",[e._v("Symbol.asyncIterator")])]),e._v(" "),n("blockquote",[n("p",[e._v("一个返回对象默认的异步迭代器的方法。使用 for await of。")])]),e._v(" "),n("h4",{attrs:{id:"正则表达式-symbols"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#正则表达式-symbols"}},[e._v("#")]),e._v(" 正则表达式 symbols")]),e._v(" "),n("ul",[n("li",[e._v("Symbol.match")])]),e._v(" "),n("blockquote",[n("p",[e._v("一个用于对字符串进行匹配的方法，也用于确定一个对象是否可以作为正则表达式使用。使用 String.prototype.match().")])]),e._v(" "),n("ul",[n("li",[e._v("Symbol.replace")])]),e._v(" "),n("blockquote",[n("p",[e._v("一个替换匹配字符串的子串的方法. 使用 String.prototype.replace().")])]),e._v(" "),n("ul",[n("li",[e._v("Symbol.search")])]),e._v(" "),n("blockquote",[n("p",[e._v("一个返回一个字符串中与正则表达式相匹配的索引的方法。使用 String.prototype.search().")])]),e._v(" "),n("ul",[n("li",[e._v("Symbol.split")])]),e._v(" "),n("blockquote",[n("p",[e._v("一个在匹配正则表达式的索引处拆分一个字符串的方法.。使用 String.prototype.split().")])]),e._v(" "),n("h4",{attrs:{id:"其他-symbols"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#其他-symbols"}},[e._v("#")]),e._v(" 其他 symbols")]),e._v(" "),n("ul",[n("li",[e._v("Symbol.hasInstance")])]),e._v(" "),n("blockquote",[n("p",[e._v("一个确定一个构造器对象识别的对象是否为它的实例的方法。使用\ninstanceof.")])]),e._v(" "),n("ul",[n("li",[e._v("Symbol.isConcatSpreadable")])]),e._v(" "),n("blockquote",[n("p",[e._v("一个布尔值，表明一个对象是否应该 flattened 为它的数组元素。使用 Array.prototype.concat().")])]),e._v(" "),n("ul",[n("li",[e._v("Symbol.unscopables")])]),e._v(" "),n("blockquote",[n("p",[e._v("拥有和继承属性名的一个对象的值被排除在与环境绑定的相关对象外。")])]),e._v(" "),n("ul",[n("li",[e._v("Symbol.species")])]),e._v(" "),n("blockquote",[n("p",[e._v("一个用于创建派生对象的构造器函数。")])]),e._v(" "),n("ul",[n("li",[e._v("Symbol.toPrimitive")])]),e._v(" "),n("blockquote",[n("p",[e._v("一个将对象转化为基本数据类型的方法。")])]),e._v(" "),n("blockquote",[n("p",[e._v("Symbol.toStringTag")])]),e._v(" "),n("ul",[n("li",[e._v("用于对象的默认描述的字符串值。使用 Object.prototype.toString().")])]),e._v(" "),n("h4",{attrs:{id:"symbol-hasinstance-方法"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#symbol-hasinstance-方法"}},[e._v("#")]),e._v(" Symbol.hasInstance 方法")]),e._v(" "),n("blockquote",[n("p",[e._v("一个确定一个构造器对象识别的对象是否为它的实例的方法")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("obj = new Array();\n\nconsole.log(obj instanceof Array); //true\n\n\nconsole.log(Array[Symbol.hasInstance](obj)) //VM187:5 true\n\n")])])]),n("blockquote",[n("p",[e._v("我可以用它定义一个无实例的函数")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("function myObject (){\n\n}\n\nObject.defineProperty(myObject,Symbol.hasInstance,{\n    value:function(v){\n        return false\n    }\n})\n\n\nlet obj = new myObject();\n\nconsole.log(obj instanceof myObject); //false\n\n\n")])])]),n("blockquote",[n("p",[e._v("我们可以定制自己的实例，通过这种方式，可以修改内建对象但是尽量不要这么做，应该修改自己创建的构造函数")])]),e._v(" "),n("h4",{attrs:{id:"symbol-isconcatspreadable-属性"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#symbol-isconcatspreadable-属性"}},[e._v("#")]),e._v(" Symbol.isConcatSpreadable 属性")]),e._v(" "),n("blockquote",[n("p",[e._v("Symbol.isConcatSpreadable 属性是一个布尔值，如果属性为 true，则表示对象有 length 属性和数字键,这样它就可以使用数组的 concat()方法了")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("let obj = {\n    0:'a',\n    1:'b',\n    length:2,\n    [Symbol.isConcatSpreadable]:true\n}\n\nlet obj2 = {\n    1:'a',\n    s:'b',\n    length:2,\n    [Symbol.isConcatSpreadable]:true\n}\n\n\nlet message = ['hi'].concat(obj);\n\nconsole.log(message);\n\nlet message2 = ['hi'].concat(obj2);\n\nconsole.log(message2);\n\n")])])]),n("p",[n("img",{attrs:{src:"http://upload-images.jianshu.io/upload_images/10843623-a176dfab66efd797.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240",alt:"1.png"}})]),e._v(" "),n("blockquote",[n("p",[e._v("说明他会寻找数字下标，找不到就设置为空，并且从零开始")])]),e._v(" "),n("h4",{attrs:{id:"symbol-match-symbol-replace-symbol-search-symbol-split"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#symbol-match-symbol-replace-symbol-search-symbol-split"}},[e._v("#")]),e._v(" Symbol.match,Symbol.replace,Symbol.search,Symbol.split")]),e._v(" "),n("ul",[n("li",[e._v("match()")])]),e._v(" "),n("blockquote",[n("p",[e._v("match() 方法可在字符串内检索指定的值，或找到一个或多个正则表达式的匹配。")])]),e._v(" "),n("ul",[n("li",[e._v("replace()")])]),e._v(" "),n("blockquote",[n("p",[e._v("replace() 方法用于在字符串中用一些字符替换另一些字符，或替换一个与正则表达式匹配的子串。")])]),e._v(" "),n("ul",[n("li",[e._v("split()")])]),e._v(" "),n("blockquote",[n("p",[e._v("用于把一个字符串分割成字符串数组")])]),e._v(" "),n("ul",[n("li",[e._v("search()")])]),e._v(" "),n("blockquote",[n("p",[e._v("用于检索字符串中指定的子字符串，或检索与正则表达式相匹配的子字符串。")])]),e._v(" "),n("blockquote",[n("p",[e._v("以上方法时 es5d 的正则表达式的字符串匹配，但是无法使用自定义的对象来替代正则表达式进行正则匹配，es6 这些方法就可以这么操作，我们来看他们的定义")])]),e._v(" "),n("ul",[n("li",[e._v("Symbol.match 接受一个字符串的参数，如果匹配成功则返回匹配成功的数组，否则返回 null")]),e._v(" "),n("li",[e._v("Symbol.replace 接受一个字符串类型的参数和一个替换字符串，最终返回一个字符串")]),e._v(" "),n("li",[e._v("Symbol.search 接受一个字符串参数，如果匹配到内容，就返回数组的位置，否则返回-1")]),e._v(" "),n("li",[e._v("Symbol.split 接受一个字符串参数，根据内容匹配将字符串分解，并将返回分解后的数组")])]),e._v(" "),n("blockquote",[n("p",[e._v("看看栗子")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("let hasLengthOf10 = {\n    [Symbol.match]:function(value) {\n        return value.length === 10 ? [value]:null\n    },\n    [Symbol.replace]:function(value, replace) {\n        return value.length === 10 ? replace:value\n    },\n    [Symbol.search]:function(value) {\n        return value.length === 10 ? 0:-1\n    },\n    [Symbol.split]:function(value) {\n        return value.length === 10 ? [ , ]:[value]\n    }\n}\n\nlet m1 = 'Hello world' //11\nlet m2 = 'Hello john'  //10\n\nconsole.log(m1.replace(hasLengthOf10)); //[empty]\nconsole.log(m2.replace(hasLengthOf10)); //undefined\n\nconsole.log(m1.match(hasLengthOf10));//null\nconsole.log(m2.match(hasLengthOf10));//[\"Hello john\"]\n\nconsole.log(m1.search(hasLengthOf10)); //-1\nconsole.log(m2.search(hasLengthOf10)); //0\n\n\nconsole.log(m1.split(hasLengthOf10));[\"Hello world\"]\nconsole.log(m2.split(hasLengthOf10)); //[empty]\n\n")])])]),n("h4",{attrs:{id:"symbol-toprimitive-指将被调用的指定函数值的属性转换为相对应的原始值"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#symbol-toprimitive-指将被调用的指定函数值的属性转换为相对应的原始值"}},[e._v("#")]),e._v(" Symbol.toPrimitive 指将被调用的指定函数值的属性转换为相对应的原始值")]),e._v(" "),n("blockquote",[n("p",[e._v('在 Symbol.toPrimitive 属性(用作函数值)的帮助下，一个对象可被转换为原始值。该函数由字符串参数 hint 调用，目的是指定原始值转换结果的首选类型。 hint 参数可以是"number"、"string" 和 "default" 中的一种。')])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('//话不多说看栗子\n\nfunction Temp(degress){\n    this.degress = degress\n}\n\n\nTemp.prototype[Symbol.toPrimitive] = function(hint){\n    switch(hint){\n        case "string":\n            return this.degress +"\\u00b0";  //degress symbol\n\n        case "number":\n            return this.degress;\n        case "default" :\n            return this.degress+\'ly\'\n    }\n}\n\nvar t = new Temp(8);\n\nconsole.log(t+\'5555\') //8ly5555\nconsole.log(t/\'2\') //4\nconsole.log(String(t)) //8°\n\n')])])]),n("h4",{attrs:{id:"symbol-tostringtag"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#symbol-tostringtag"}},[e._v("#")]),e._v(" Symbol.toStringTag")]),e._v(" "),n("blockquote",[n("p",[e._v("Symbol.toStringTag 是一个内置 symbol，它通常作为对象的属性键使用，对应的属性值应该为字符串类型，这个字符串用来表示该对象的自定义类型标签，通常只有内置的 Object.prototype.toString() 方法会去读取这个标签并把它包含在自己的返回值里。")])]),e._v(" "),n("blockquote",[n("p",[e._v("我们识别数组还是对象，一般习惯用 toString 方法来实现，例如")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("function isArray(arr){\n    return Object.prototype.toString.call(arr) === '[object Array]'\n}\n\n")])])]),n("blockquote",[n("p",[e._v("现在我们可以重写一个对象的类型")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("function Person(name){\n    this.name =name;\n}\n\nPerson.prototype[Symbol.toStringTag] = 'Person';\n\nlet people = new Person('ly');\n\nconsole.log(Object.prototype.toString.call(people)); //[object Person]\n\n")])])]),n("h4",{attrs:{id:"symbol-unscopables-指用于指定对象值-其对象自身和继承的从关联对象的-with-环境绑定中排除的属性名称。"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#symbol-unscopables-指用于指定对象值-其对象自身和继承的从关联对象的-with-环境绑定中排除的属性名称。"}},[e._v("#")]),e._v(" Symbol.unscopables 指用于指定对象值，其对象自身和继承的从关联对象的 with 环境绑定中排除的属性名称。")]),e._v(" "),n("blockquote",[n("p",[e._v("可以在任何对象上定义 @@unscopables symbol (Symbol.unscopables)，用于排除属性名称并与 with 环境绑定在一起作为词法变量公开。 请注意，如果使用 Strict mode，语句将不可用，并且可能也不需要 symbol。")])]),e._v(" "),n("blockquote",[n("p",[e._v("在 unscopables 对象上设置属性为 true，将使其 unscopable 并且因此该属性也将不会在词法环境变量中出现。 如果设置属性为 false ，则将使其可 scopable 并且该属性会出现在词法环境变量中。")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("我们在使用with时，如果用了对象属性作为变量则会报错，例如(es6数组存在values方法)\n\nlet values = [1,2],colors=['w', 'y', 'k', 'o', 'p'],color='blue';\n\nconsole.log(colors.values());\n\nwith(colors){\n    push(color)\n    push(...values)\n    console.log(values);\n}\n\nconsole.log(colors); //[\"red\", \"blue\", 1, 2]  //emmmm,没报错的原因values()方法还没加上去\n\n//报错了就用这种方式,他是将词法排除在这个with环境中\n\nArray.prototype[Symbol.unscopables] = Object.assign(Object.create(null),{\n copyWith:true,\n entries:true,\n fill:true,\n find:true,\n findIndex:true,\n keys:true,\n values:'true'\n\n})\n\n\n")])])]),n("p",[n("img",{attrs:{src:"http://upload-images.jianshu.io/upload_images/10843623-2c5109c4f8e58e1c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240",alt:"2.png"}})])])}),[],!1,null,null,null);t.default=o.exports}}]);