(window.webpackJsonp=window.webpackJsonp||[]).push([[120],{637:function(t,n,e){"use strict";e.r(n);var s=e(6),a=Object(s.a)({},(function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("blockquote",[e("p",[t._v("react-State and Lifecycle")])]),t._v(" "),e("h1",{attrs:{id:"利用定时器实现-ui-的刷新"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#利用定时器实现-ui-的刷新"}},[t._v("#")]),t._v(" 利用定时器实现 UI 的刷新")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("function Clock(props) {\n  return (\n    <div>\n      <h1>Hello, world!</h1>\n      <h2>It is {props.date.toLocaleTimeString()}.</h2>\n    </div>\n  );\n}\n\nfunction tick() {\n  ReactDOM.render(\n    <Clock date={new Date()} />,\n    document.getElementById('root')\n  );\n}\n\nsetInterval(tick, 1000);\n")])])]),e("blockquote",[e("p",[t._v("这样的方法导致 ui 每秒都在更新，即时用户没有改变数据也在实时刷新，导致性能差，替代的方法是定义一个 state 作为一个定时器，他类似于 props，但是他是私有的，控制着整个组件。")])]),t._v(" "),e("h1",{attrs:{id:"从函数到类的转变-converting-a-function-to-a-class"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#从函数到类的转变-converting-a-function-to-a-class"}},[t._v("#")]),t._v(" 从函数到类的转变 Converting a Function to a Class")]),t._v(" "),e("blockquote",[e("p",[t._v("function 的写法")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("function Add(props){\n    return (<div>\n         {props.a}+{props.b}={props.a+props.b}\n    </div>)\n}\n")])])]),e("blockquote",[e("p",[t._v("es6 写法")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("class Add extends Component {\n    render() {\n        return (\n            <div>\n                这是es6的语法哦\n                {this.props.a}+{this.props.b} = {this.props.a+this.props.b}\n            </div>\n        )\n    }\n}\n")])])]),e("blockquote",[e("p",[t._v("新增一个 class constructor 来初始化 this.state")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("class Show extends Component{\n    constructor(props) {\n        super(props)\n        this.state={\n            name:'ly',\n            age:18\n        }\n    }\n\n    render () {\n        return (\n            <div>\n                <p>name:{this.state.name}</p>\n                <p>age:{this.state.age}</p>\n            </div>\n        )\n    }\n\n}\n")])])]),e("h1",{attrs:{id:"生命周期-adding-lifecycle-methods-to-a-class"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#生命周期-adding-lifecycle-methods-to-a-class"}},[t._v("#")]),t._v(" 生命周期 Adding Lifecycle Methods to a Class")]),t._v(" "),e("blockquote",[e("p",[t._v("componentDidMount 执行的条件是在第一次加载组件完成时触发")])]),t._v(" "),e("blockquote",[e("p",[t._v("componentWillUnmount 执行的条件是组件即将被销毁")])]),t._v(" "),e("blockquote",[e("p",[t._v("利用这两个钩子函数可以实现时钟的实时更新，仅在局部的更新")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("class Show extends Component{\n    constructor(props) {\n        super(props)\n        this.state={\n            name:'ly',\n            age:18,\n            date: new Date().toLocaleString()\n        }\n\n    }\n\n    componentDidMount(){\n        this.timer = setInterval(() => this.show(),1000)\n    }\n\n    show () {\n        this.setState({\n            date:new Date().toLocaleString()\n        })\n\n        //状态不能通过this.state.date=new Date().toLocalString() The only place where you can assign this.state is the constructor. 构造器可以直接操作\n    }\n\n    componentWillUnmount(){\n            clearInterval(this.timer)\n    }\n\n    render () {\n        return (\n            <div>\n                <p>name:{this.state.name}</p>\n                <p>age:{this.state.age}</p>\n                <p>现在的时间:{this.state.date}</p>\n            </div>\n        )\n    }\n\n}\n")])])]),e("h1",{attrs:{id:"state-状态的改变是异步的-state-updates-may-be-asynchronous"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#state-状态的改变是异步的-state-updates-may-be-asynchronous"}},[t._v("#")]),t._v(" state 状态的改变是异步的 State Updates May Be Asynchronous")]),t._v(" "),e("blockquote",[e("p",[t._v("我们在使用 props 和 state 时 不应该依赖它们的值来计算下一个状态")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("//wrong\n\ncomponentDidMount () {\n        this.setState({\n            counter1:this.state.counter1+this.state.counter2\n        })\n\n}\n\n// correct\ncomponentDidMount () {\n        this.setState(function (prevState,props) {\n            console.log(prevState,props);\n             return {\n                 counter1:prevState.counter1+props.counter2\n             }\n        })\n\n}\n")])])]),e("h1",{attrs:{id:"父元素向子元素传递信息-the-data-flows-down"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#父元素向子元素传递信息-the-data-flows-down"}},[t._v("#")]),t._v(" 父元素向子元素传递信息 The Data Flows Down")]),t._v(" "),e("blockquote",[e("p",[t._v("A component may choose to pass its state down as props to its child components")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('class Down extends Component{\n     constructor(props){\n         super(props)\n     }\n\n     render () {\n         return (\n             <div>\n                 <p>从父元素传数据过来了{this.props.data}</p>\n             </div>\n         )\n     }\n}\n\n\nclass App extends Component {\n    constructor(props){\n        super(props)\n        this.state={\n            data:"飞呀飞呀"\n        }\n    }\n\n  render() {\n    return (\n      <div className="App">\n            <Show/>\n            <Add/>\n            <Down data={this.state.data}/>\n\n      </div>\n    );\n  }\n}\n')])])]),e("blockquote",[e("p",[t._v('This is commonly called a "top-down" or "unidirectional" data flow')])])])}),[],!1,null,null,null);n.default=a.exports}}]);