(window.webpackJsonp=window.webpackJsonp||[]).push([[28],{542:function(t,e,s){"use strict";s.r(e);var a=s(6),n=Object(a.a)({},(function(){var t=this,e=t.$createElement,s=t._self._c||e;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"async与await体验"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#async与await体验"}},[t._v("#")]),t._v(" async与await体验")]),t._v(" "),s("blockquote",[s("p",[t._v("第一次用es7的语法，在实际的开发中可能用的比较少，但是作为前端这也算是一个趋势，先留个坑，以后慢慢学习")])]),t._v(" "),s("h2",{attrs:{id:"基本语法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#基本语法"}},[t._v("#")]),t._v(" 基本语法")]),t._v(" "),s("blockquote",[s("p",[t._v("async是一个异步的函数，通过它进行定义")])]),t._v(" "),s("blockquote",[s("p",[t._v("await只能用在async函数的里面，它的出现必须要等到一个promise返回结构才能继续执行")])]),t._v(" "),s("h2",{attrs:{id:"基本用法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#基本用法"}},[t._v("#")]),t._v(" 基本用法")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v('const sleep = (time) => new Promise((resolve,reject) => {\n\t\tsetTimeout(() => {\n\t\t\t  resolve("ok");\n\t\t},time)\n})\n\nconst test = async() => {\n       console.log("start");\n       const ok = await sleep(3000);\n\n       console.log(ok);\n\n       console.log("end");\n}\n\ntest();  //start   ok  end\n')])])]),s("h2",{attrs:{id:"捕捉错误"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#捕捉错误"}},[t._v("#")]),t._v(" 捕捉错误")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("const sleep = (time) => new Promise((resolve,reject) =>{\n\t\tsetTimeout(() => reject(\"你错了\"),time)\n})\n\nconst run = async() => {\n\n\t try{\n\n\t \tconsole.log('start');\n\t \tawait sleep(3000);\n\t \tconsole.log('end');\n\n\t }catch(err){\n\t\tconsole.log(err);\n\t }finally{\n\t \tconsole.log('over');\n\t }\n\t console.log('over1');\n}\n\nrun();//\tstart  你错了  over  over1\n")])])]),s("h2",{attrs:{id:"循环多个await-它类似于同步代码-不用担心需要闭包才能解决问题"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#循环多个await-它类似于同步代码-不用担心需要闭包才能解决问题"}},[t._v("#")]),t._v(" 循环多个await 它类似于同步代码 不用担心需要闭包才能解决问题")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("const sleep = (time) => new Promise((resolve,reject) =>{\n\t\tsetTimeout(() => resolve(true),time)\n})\n\nvar run = async() => {\n\t\tfor (let i = 0;i<3;i++) {\n\t\t\t  console.log(`当前是第${i}次等待..`);\n\t\t\t  await sleep(1000);\n\t\t}\n}\n\n\nrun();//当前是第0次等待..\t当前是第1次等待..\t当前是第2次等待..\n")])])]),s("h2",{attrs:{id:"async返回的是什么-返回的是promise对象"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#async返回的是什么-返回的是promise对象"}},[t._v("#")]),t._v(" async返回的是什么  返回的是promise对象！！！！")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v('const add =async() => {\n\t\treturn "hello world"\n}\n\nconsole.log(add()); //Promise {[[PromiseStatus]]: "resolved", [[PromiseValue]]: "hello world"}\n\nadd().then((value)=>console.log(value));  //hello world\n')])])])])}),[],!1,null,null,null);e.default=n.exports}}]);