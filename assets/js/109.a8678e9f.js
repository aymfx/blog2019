(window.webpackJsonp=window.webpackJsonp||[]).push([[109],{623:function(e,s,r){"use strict";r.r(s);var n=r(6),o=Object(n.a)({},(function(){var e=this,s=e.$createElement,r=e._self._c||s;return r("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[r("blockquote",[r("p",[e._v("Promise.all方法用于将多个 Promise 实例，包装成一个新的 Promise 实例。")])]),e._v(" "),r("h1",{attrs:{id:"promise-all"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#promise-all"}},[e._v("#")]),e._v(" Promise.all()")]),e._v(" "),r("p",[e._v("Promise.all方法用于将多个 Promise 实例，包装成一个新的 Promise 实例。")]),e._v(" "),r("p",[e._v("var p = Promise.all([p1, p2, p3]);\n上面代码中，Promise.all方法接受一个数组作为参数，p1、p2、p3都是 Promise 实例，如果不是，就会先调用下面讲到的Promise.resolve方法，将参数转为 Promise 实例，再进一步处理。（Promise.all方法的参数可以不是数组，但必须具有 Iterator 接口，且返回的每个成员都是 Promise 实例。）")]),e._v(" "),r("p",[e._v("p的状态由p1、p2、p3决定，分成两种情况。")]),e._v(" "),r("p",[e._v("（1）只有p1、p2、p3的状态都变成fulfilled，p的状态才会变成fulfilled，此时p1、p2、p3的返回值组成一个数组，传递给p的回调函数。")]),e._v(" "),r("p",[e._v("（2）只要p1、p2、p3之中有一个被rejected，p的状态就变成rejected，此时第一个被reject的实例的返回值，会传递给p的回调函数。")]),e._v(" "),r("p",[e._v("下面是一个具体的例子。")]),e._v(" "),r("p",[e._v("// 生成一个Promise对象的数组")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",[r("code",[e._v("var promises = [2, 3, 5, 7, 11, 13].map(function (id) {\n  return getJSON('/post/' + id + \".json\");\n});\n\nPromise.all(promises).then(function (posts) {\n  // ...\n}).catch(function(reason){\n  // ...\n});\n")])])]),r("p",[e._v("上面代码中，promises是包含6个 Promise 实例的数组，只有这6个实例的状态都变成fulfilled，或者其中有一个变为rejected，才会调用Promise.all方法后面的回调函数。")]),e._v(" "),r("p",[e._v("下面是另一个例子。")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",[r("code",[e._v("const databasePromise = connectDatabase();\n\nconst booksPromise = databasePromise\n  .then(findAllBooks);\n\nconst userPromise = databasePromise\n  .then(getCurrentUser);\n\nPromise.all([\n  booksPromise,\n  userPromise\n])\n.then(([books, user]) => pickTopRecommentations(books, user));\n")])])]),r("p",[e._v("上面代码中，booksPromise和userPromise是两个异步操作，只有等到它们的结果都返回了，才会触发pickTopRecommentations这个回调函数。")]),e._v(" "),r("p",[e._v("注意，如果作为参数的 Promise 实例，自己定义了catch方法，那么它一旦被rejected，并不会触发Promise.all()的catch方法。")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",[r("code",[e._v("const p1 = new Promise((resolve, reject) => {\n  resolve('hello');\n})\n.then(result => result)\n.catch(e => e);\n\nconst p2 = new Promise((resolve, reject) => {\n  throw new Error('报错了');\n})\n.then(result => result)\n.catch(e => e);\n\nPromise.all([p1, p2])\n.then(result => console.log(result))\n.catch(e => console.log(e));\n// [\"hello\", Error: 报错了]\n")])])]),r("p",[e._v("上面代码中，p1会resolved，p2首先会rejected，但是p2有自己的catch方法，该方法返回的是一个新的 Promise 实例，p2指向的实际上是这个实例。该实例执行完catch方法后，也会变成resolved，导致Promise.all()方法参数里面的两个实例都会resolved，因此会调用then方法指定的回调函数，而不会调用catch方法指定的回调函数。")]),e._v(" "),r("p",[e._v("如果p2没有自己的catch方法，就会调用Promise.all()的catch方法。")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",[r("code",[e._v("const p1 = new Promise((resolve, reject) => {\n  resolve('hello');\n})\n.then(result => result);\n\nconst p2 = new Promise((resolve, reject) => {\n  throw new Error('报错了');\n})\n.then(result => result);\n\nPromise.all([p1, p2])\n.then(result => console.log(result))\n.catch(e => console.log(e));\n// Error: 报错了\n")])])]),r("h1",{attrs:{id:"promise-race"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#promise-race"}},[e._v("#")]),e._v(" Promise.race()")]),e._v(" "),r("p",[e._v("Promise.race方法同样是将多个Promise实例，包装成一个新的Promise实例。")]),e._v(" "),r("p",[e._v("var p = Promise.race([p1, p2, p3]);\n上面代码中，只要p1、p2、p3之中有一个实例率先改变状态，p的状态就跟着改变。那个率先改变的 Promise 实例的返回值，就传递给p的回调函数。")]),e._v(" "),r("p",[e._v("Promise.race方法的参数与Promise.all方法一样，如果不是 Promise 实例，就会先调用下面讲到的Promise.resolve方法，将参数转为 Promise 实例，再进一步处理。")]),e._v(" "),r("p",[e._v("下面是一个例子，如果指定时间内没有获得结果，就将Promise的状态变为reject，否则变为resolve。")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",[r("code",[e._v("const p = Promise.race([\n  fetch('/resource-that-may-take-a-while'),\n  new Promise(function (resolve, reject) {\n    setTimeout(() => reject(new Error('request timeout')), 5000)\n  })\n]);\np.then(response => console.log(response));\np.catch(error => console.log(error));\n")])])]),r("p",[e._v("上面代码中，如果5秒之内fetch方法无法返回结果，变量p的状态就会变为rejected，从而触发catch方法指定的回调函数。")]),e._v(" "),r("h1",{attrs:{id:"promise-resolve"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#promise-resolve"}},[e._v("#")]),e._v(" Promise.resolve()")]),e._v(" "),r("p",[e._v("有时需要将现有对象转为Promise对象，Promise.resolve方法就起到这个作用。")]),e._v(" "),r("p",[e._v("var jsPromise = Promise.resolve($.ajax('/whatever.json'));\n上面代码将jQuery生成的deferred对象，转为一个新的Promise对象。")]),e._v(" "),r("p",[e._v("Promise.resolve等价于下面的写法。")]),e._v(" "),r("p",[e._v("Promise.resolve('foo')\n// 等价于\nnew Promise(resolve => resolve('foo'))\nPromise.resolve方法的参数分成四种情况。")]),e._v(" "),r("p",[e._v("（1）参数是一个Promise实例")]),e._v(" "),r("p",[e._v("如果参数是Promise实例，那么Promise.resolve将不做任何修改、原封不动地返回这个实例。")]),e._v(" "),r("p",[e._v("（2）参数是一个thenable对象")]),e._v(" "),r("p",[e._v("thenable对象指的是具有then方法的对象，比如下面这个对象。")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",[r("code",[e._v("let thenable = {\n  then: function(resolve, reject) {\n    resolve(42);\n  }\n};\n")])])]),r("p",[e._v("Promise.resolve方法会将这个对象转为Promise对象，然后就立即执行thenable对象的then方法。")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",[r("code",[e._v("let thenable = {\n  then: function(resolve, reject) {\n    resolve(42);\n  }\n};\n\nlet p1 = Promise.resolve(thenable);\np1.then(function(value) {\n  console.log(value);  // 42\n});\n")])])]),r("p",[e._v("上面代码中，thenable对象的then方法执行后，对象p1的状态就变为resolved，从而立即执行最后那个then方法指定的回调函数，输出42。")]),e._v(" "),r("p",[e._v("（3）参数不是具有then方法的对象，或根本就不是对象")]),e._v(" "),r("p",[e._v("如果参数是一个原始值，或者是一个不具有then方法的对象，则Promise.resolve方法返回一个新的Promise对象，状态为Resolved。")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",[r("code",[e._v("var p = Promise.resolve('Hello');\n\np.then(function (s){\n  console.log(s)\n});\n// Hello\n")])])]),r("p",[e._v("上面代码生成一个新的Promise对象的实例p。由于字符串Hello不属于异步操作（判断方法是字符串对象不具有then方法），返回Promise实例的状态从一生成就是Resolved，所以回调函数会立即执行。Promise.resolve方法的参数，会同时传给回调函数。")]),e._v(" "),r("p",[e._v("（4）不带有任何参数")]),e._v(" "),r("p",[e._v("Promise.resolve方法允许调用时不带参数，直接返回一个Resolved状态的Promise对象。")]),e._v(" "),r("p",[e._v("所以，如果希望得到一个Promise对象，比较方便的方法就是直接调用Promise.resolve方法。")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",[r("code",[e._v("var p = Promise.resolve();\n\np.then(function () {\n  // ...\n});\n")])])]),r("p",[e._v("上面代码的变量p就是一个Promise对象。")]),e._v(" "),r("p",[e._v("需要注意的是，立即resolve的Promise对象，是在本轮“事件循环”（event loop）的结束时，而不是在下一轮“事件循环”的开始时。")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",[r("code",[e._v("setTimeout(function () {\n  console.log('three');\n}, 0);\n\nPromise.resolve().then(function () {\n  console.log('two');\n});\n\nconsole.log('one');\n\n// one\n// two\n// three\n")])])]),r("p",[e._v("上面代码中，setTimeout(fn, 0)在下一轮“事件循环”开始时执行，Promise.resolve()在本轮“事件循环”结束时执行，console.log('one')则是立即执行，因此最先输出。")]),e._v(" "),r("h1",{attrs:{id:"promise-reject"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#promise-reject"}},[e._v("#")]),e._v(" Promise.reject()")]),e._v(" "),r("p",[e._v("Promise.reject(reason)方法也会返回一个新的 Promise 实例，该实例的状态为rejected。")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",[r("code",[e._v("var p = Promise.reject('出错了');\n// 等同于\nvar p = new Promise((resolve, reject) => reject('出错了'))\n\np.then(null, function (s) {\n  console.log(s)\n});\n")])])]),r("p",[e._v("// 出错了\n上面代码生成一个Promise对象的实例p，状态为rejected，回调函数会立即执行。")]),e._v(" "),r("p",[e._v("注意，Promise.reject()方法的参数，会原封不动地作为reject的理由，变成后续方法的参数。这一点与Promise.resolve方法不一致。")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",[r("code",[e._v("const thenable = {\n  then(resolve, reject) {\n    reject('出错了');\n  }\n};\n\nPromise.reject(thenable)\n.catch(e => {\n  console.log(e === thenable)\n})\n// true\n")])])]),r("p",[e._v("上面代码中，Promise.reject方法的参数是一个thenable对象，执行以后，后面catch方法的参数不是reject抛出的“出错了”这个字符串，而是thenable对象。")]),e._v(" "),r("h1",{attrs:{id:"两个有用的附加方法"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#两个有用的附加方法"}},[e._v("#")]),e._v(" 两个有用的附加方法")]),e._v(" "),r("p",[e._v("ES6的Promise API提供的方法不是很多，有些有用的方法可以自己部署。下面介绍如何部署两个不在ES6之中、但很有用的方法。")]),e._v(" "),r("p",[e._v("done()\nPromise对象的回调链，不管以then方法或catch方法结尾，要是最后一个方法抛出错误，都有可能无法捕捉到（因为Promise内部的错误不会冒泡到全局）。因此，我们可以提供一个done方法，总是处于回调链的尾端，保证抛出任何可能出现的错误。")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",[r("code",[e._v("asyncFunc()\n  .then(f1)\n  .catch(r1)\n  .then(f2)\n  .done();\n")])])]),r("p",[e._v("它的实现代码相当简单。")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",[r("code",[e._v("Promise.prototype.done = function (onFulfilled, onRejected) {\n  this.then(onFulfilled, onRejected)\n    .catch(function (reason) {\n      // 抛出一个全局错误\n      setTimeout(() => { throw reason }, 0);\n    });\n};\n")])])]),r("p",[e._v("从上面代码可见，done方法的使用，可以像then方法那样用，提供Fulfilled和Rejected状态的回调函数，也可以不提供任何参数。但不管怎样，done都会捕捉到任何可能出现的错误，并向全局抛出。")]),e._v(" "),r("h1",{attrs:{id:"finally"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#finally"}},[e._v("#")]),e._v(" finally()")]),e._v(" "),r("p",[e._v("finally方法用于指定不管Promise对象最后状态如何，都会执行的操作。它与done方法的最大区别，它接受一个普通的回调函数作为参数，该函数不管怎样都必须执行。")]),e._v(" "),r("p",[e._v("下面是一个例子，服务器使用Promise处理请求，然后使用finally方法关掉服务器。")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",[r("code",[e._v("server.listen(0)\n  .then(function () {\n    // run test\n  })\n  .finally(server.stop);\n")])])]),r("p",[e._v("它的实现也很简单。")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",[r("code",[e._v("Promise.prototype.finally = function (callback) {\n  let P = this.constructor;\n  return this.then(\n    value  => P.resolve(callback()).then(() => value),\n    reason => P.resolve(callback()).then(() => { throw reason })\n  );\n};\n")])])]),r("p",[e._v("上面代码中，不管前面的Promise是fulfilled还是rejected，都会执行回调函数callback。")])])}),[],!1,null,null,null);s.default=o.exports}}]);