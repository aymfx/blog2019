(window.webpackJsonp=window.webpackJsonp||[]).push([[125],{638:function(t,n,e){"use strict";e.r(n);var o=e(6),s=Object(o.a)({},(function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("blockquote",[e("p",[t._v("对于在哪里进行setState()的操作请看下面这个例子")])]),t._v(" "),e("p",[t._v("import React,{Component , PropTypes} from 'react'\nimport '../css/Life.scss';")]),t._v(" "),e("p",[t._v("class Life extends Component{\nconstructor (props) {\nsuper(props)\nthis.state={\ncount:1,\nname:'点我',\nnum:0\n}\n//有警告，页面能刷新正常运行，但是不会加1 此构造函数只执行一次\n// this.setState(prevState =>({count:prevState.count+1}))\nconsole.log(\"constructor\",this.props,0);\nthis.handleEvent = this.handleEvent.bind(this)\n}")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v('  handleEvent () {\n\n      this.setState(prevState => ({count:prevState.count+1}))\n  }\n\n  static propsTyps = {\n      age:PropTypes.number,\n      sex:PropTypes.string,\n  }\n\n   static defaultProps = {\n\n   }\n\n   componentWillMount () {\n       //执行这个函数，然后加1，然后渲染 此构造函数只执行一次\n       // this.setState(prevState =>({count:prevState.count+1}))\n      console.log("componentWillMount,",111);\n   }\n\n   render(){\n       console.log("render,",2222);\n       //有警告，且直接运行不了 Maximum call stack size exceeded\n       //  this.setState(prevState =>({count:prevState.count+1}))\n      return (<div>\n            <p>计数:{this.state.count}</p>\n            <p>年龄:{this.props.age}</p>\n            <button onClick={this.handleEvent}>{this.state.name}</button>\n      </div>)\n   }\n\n   componentDidMount () {\n        //渲染后，执行这个函数，然后又加1，再次渲染---此钩子只执行一次\n       // this.setState(prevState =>({count:prevState.count+1}))\n       console.log("componentDidMount,",3333);\n   }\n\n   componentWillReceiveProps (nextProps) {\n       //这个主要用于父组件改变了传入的props，才进行触发事件\n       //这个也可以支持设置状态\n       //  this.setState(prevState =>({count:prevState.count+1}))\n       console.log("componentWillReceiveProps",nextProps,4444);\n   }\n\n   shouldComponentUpdate(nextProps,nextState) {\n       //他主要作用就是是否更新组件，true表示更新，false表示不更新\n       //这个也可以支持设置状态，但是书上说不可以，也许有别的原因\n       // this.setState(prevState =>({count:prevState.count+1}))\n       // debugger;\n       console.log(nextState,nextProps,55555);\n       return true;\n   }\n\n   componentWillUpdate(nextProps,nextState) {\n        //放在这里容易造成死循环\n     // this.setState(prevState =>({count:prevState.count+1}))\n       console.log(nextState,nextProps,66666);\n   }\n\n   componentDidUpdate() {\n       //放在这里容易造成死循环,最好加判断\n       if(this.state.count<20){\n           this.setState(prevState =>({count:prevState.count+1}))\n       }\n\n       console.log(\'componentDidUpdate\',77777);\n   }\n')])])]),e("p",[t._v("}")]),t._v(" "),e("p",[t._v("export default Life;")]),t._v(" "),e("blockquote",[e("p",[t._v("上面是子组件")])]),t._v(" "),e("blockquote",[e("p",[t._v("我是父组件")])]),t._v(" "),e("p",[t._v("import React, { Component } from 'react';\nimport logo from './logo.svg';\nimport './css/App.scss';\nimport Life from './components/Life'")]),t._v(" "),e("p",[t._v("class App extends Component {\nconstructor(props) {\nsuper(props)\nthis.state={\nage:18\n}\n}")]),t._v(" "),e("p",[t._v("render() {\nreturn (\n")]),e("div",{attrs:{className:"App"}},[e("div",{attrs:{className:"App-header"}},[e("img",{attrs:{src:"{logo}",className:"App-logo",alt:"logo"}}),t._v(" "),e("h2",[t._v("Welcome to React")])]),t._v(" "),e("div",[e("Life",{attrs:{age:"{this.state.age}",sex:"男"}}),t._v('\n<input type="text" value={this.state.age} onChange={(e)=>{this.setState({age:e.target.value})}}/>\n')],1)]),t._v("\n);\n}\n}"),e("p"),t._v(" "),e("p",[t._v("export default App;")]),t._v(" "),e("h1",{attrs:{id:"总结"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[t._v("#")]),t._v(" 总结")]),t._v(" "),e("blockquote",[e("p",[t._v("现在学的比较浅，组件有 construct componentWillMount() 以及componentDidMount在初始化过程中只执行一次,其他钩子函数在数据状态改变时会执行。")])]),t._v(" "),e("blockquote")])}),[],!1,null,null,null);n.default=s.exports}}]);